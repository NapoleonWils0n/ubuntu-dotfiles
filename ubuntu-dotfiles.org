#TITLE: ubuntu dotfiles
#+STARTUP: show2levels hideblocks
#+OPTIONS: num:nil author:nil
#+PROPERTY: header-args :mkdirp yes :noweb yes 
* ubuntu dotfiles
** update
*** tangle dotfiles
**** tangle document

C-c C-v t

**** tangle only one code block

C-u C-c C-v t

**** tangle from the command line

#+begin_src sh
emacs --batch -l org --eval '(org-babel-tangle-file "~/git/ubuntu-dotfiles/ubuntu-dotfiles.org")'
#+end_src

** emacs
*** emacs config
**** init.el
:PROPERTIES:
:header-args: :noweb-ref init.el :noweb-sep "\n\n"
:END:

#+begin_example
~/.config/emacs/init.el
#+end_example

***** emacs-startup-hook

#+NAME: emacs-startup-hook
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; emacs init.el - also using early-init.el
;; ----------------------------------------------------------------------------------

;; Use a hook so the message doesn't get clobbered by other messages.
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs ready in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+end_src

***** bootstrap use package

#+NAME: emacs-bootstrap-use-package
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Bootstrap use-package
;; ----------------------------------------------------------------------------------

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package))

(setq use-package-always-ensure t) ;; Automatically install packages if not present


;; ----------------------------------------------------------------------------------
;; melpa packages
;; ----------------------------------------------------------------------------------

(unless (assoc-default "melpa" package-archives)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t))
(unless (assoc-default "elpa" package-archives)
  (add-to-list 'package-archives '("elpa" . "https://elpa.gnu.org/packages/") t))

;; package initialize (use-package will handle installation and requiring)
(package-initialize)
#+end_src

***** themes

#+NAME: emacs-themes
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; doom-theme : use-package
;; ----------------------------------------------------------------------------------

;; doom themes
(use-package doom-themes)

;; ----------------------------------------------------------------------------------
;; modus-vivendi-tinted : load-theme
;; ----------------------------------------------------------------------------------

(load-theme 'modus-vivendi-tinted t)
#+end_src

****** info

Modus Themes

#+begin_quote
Accessible themes for GNU Emacs,
conforming with the highest standard for colour contrast between background and foreground values
#+end_quote

[[https://protesilaos.com/emacs/modus-themes]]

***** setq

#+NAME: emacs-setq
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; general settings : setq
;; ----------------------------------------------------------------------------------

;; Save all tempfiles in ~/.config/emacs/backups
(setq backup-directory-alist '(("." . "~/.config/emacs/backups")))

;; auto save list
(setq auto-save-file-name-transforms '((".*" "~/.config/emacs/auto-save-list/" t)))

;; history
(setq savehist-file "~/.config/emacs/savehist")
(savehist-mode 1)

(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))


;; dont backup files opened by sudo or doas
(setq backup-enable-predicate
      (lambda (name)
        (and (normal-backup-enable-predicate name)
             (not
              (let ((method (file-remote-p name 'method)))
                (when (stringp method)
                  (member method '("su" "sudo" "doas"))))))))


;; save
(save-place-mode 1)         ;; save cursor position
(desktop-save-mode 0)       ;; dont save the desktop session
(global-auto-revert-mode 1) ;; revert buffers when the underlying file has changed

;; scrolling
(pixel-scroll-precision-mode 1)

;; version control
(setq version-control t)
(setq vc-make-backup-files t)
(setq backup-by-copying t)
(setq delete-old-versions t)
(setq kept-new-versions 6)
(setq kept-old-versions 2)
(setq create-lockfiles nil)
(setq undo-tree-auto-save-history nil)

;; pinentry
(defvar epa-pinentry-mode)
(setq epa-pinentry-mode 'loopback)

;; display time in mode line, hide load average
(setq display-time-format "%H:%M")
(setq display-time-default-load-average nil)
(display-time-mode 1)       ;; display time

;; change prompt from yes or no, to y or n
(setq use-short-answers t)

;; turn off blinking cursor
(setq blink-cursor-mode nil)

;; suppress large file prompt
(setq large-file-warning-threshold nil)

;; always follow symlinks
(setq vc-follow-symlinks t)

;; case insensitive search
(setq read-file-name-completion-ignore-case t)
(setq completion-ignore-case t)

;; M-n, M-p recall previous mini buffer commands
(setq history-length 25)

;; Use spaces instead of tabs
(setq-default indent-tabs-mode nil)

;; revert dired and other buffers
(setq global-auto-revert-non-file-buffers t)

;; eww browser text width
(setq shr-width 80)

;; ediff
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
(setq ediff-split-window-function 'split-window-horizontally)

;; disable ring bell
(setq ring-bell-function 'ignore)

;; side windows
(setq switch-to-buffer-obey-display-actions t)

;; hippie expand
(setq save-abbrevs 'silently)
(setq hippie-expand-try-functions-list
      '(try-expand-all-abbrevs
        try-complete-file-name-partially
        try-complete-file-name
        try-expand-dabbrev
        try-expand-dabbrev-from-kill
        try-expand-dabbrev-all-buffers
        try-expand-list
        try-expand-line
        try-complete-lisp-symbol-partially
        try-complete-lisp-symbol))

;; emacs 28 - dictionary server
(setq dictionary-server "localhost")

;; mpd host
(setq mpc-host "/home/djwilcox/.config/mpd/socket")
#+end_src

***** xkb fix for alt and super

#+NAME: emacs-xkb-mac
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; xkb fix for alt and super on mac osx
;; ----------------------------------------------------------------------------------

(setq x-alt-keysym 'meta)
(setq x-super-keysym 'meta)
#+end_src

***** tab bar mode

#+NAME: emacs-tab-bar
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; TAB bar mode
;; ----------------------------------------------------------------------------------

(setq tab-bar-show 1)                     ;; hide bar if <= 1 tabs open
(setq tab-bar-close-button-show nil)      ;; hide close tab button
(setq tab-bar-new-button-show nil)        ;; hide new tab button
(setq tab-bar-new-tab-choice "*scratch*") ;; default tab scratch
(setq tab-bar-close-last-tab-choice 'tab-bar-mode-disable) 
(setq tab-bar-close-tab-select 'recent)
(setq tab-bar-new-tab-to 'right)
(setq tab-bar-tab-hints nil)
(setq tab-bar-separator " ")
(setq tab-bar-auto-width-max '((100) 20))
(setq tab-bar-auto-width t)

;; Customize the tab bar format to add the global mode line string
(setq tab-bar-format '(tab-bar-format-tabs tab-bar-separator tab-bar-format-align-right tab-bar-format-global))

;; menubar in tab bar
(add-to-list 'tab-bar-format #'tab-bar-format-menu-bar)

;; Turn on tab bar mode after startup
(tab-bar-mode 1)

;; tab bar menu bar button
(setq tab-bar-menu-bar-button "üëø")
#+end_src

****** info

#+begin_quote
On graphical displays and on text terminals, Emacs can optionally display a Tab Bar at the top of each frame, just below the menu bar (see Menu Bars) and above or below the tool bar (see Tool Bars) depending on the variable tab-bar-position. The Tab Bar is a row of tabs‚Äîbuttons that you can click to switch between window configurations. 
#+end_quote

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Tab-Bars.html]]

***** buffer list

#+NAME: emacs-buffer-list
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; buffer list
;; ----------------------------------------------------------------------------------

;; display Buffer List in same window
(add-to-list 'display-buffer-alist
             '("^*Buffer List*" display-buffer-same-window))


;; mandatory, as the dictionary misbehaves!
(add-to-list 'display-buffer-alist
             '("^\\*Dictionary\\*" display-buffer-in-side-window
               (side . right)
               (window-width . 0.50)))

;; Man display in current buffer
(setq Man-notify-method 'bully)
#+end_src

***** functions

#+NAME: emacs-functions
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; functions
;; ----------------------------------------------------------------------------------

;; clear the kill ring
(defun clear-kill-ring ()
  "Clear the results on the kill ring."
  (interactive)
  (setq kill-ring nil))

;; reload init.el
(defun my-reload-init ()
  "reload init.el"
  (interactive)
  (load-file "~/.config/emacs/init.el"))

;; pinch - play urls with mpd
(defun pinch-clipboard ()
  "Send a url from the clipboard to mpd with pinch"
  (interactive)
  (let ((url (current-kill 0 t)))
    (start-process "pinch" nil "pinch" "-i" url)))

;; wayland clipboard
(setq wl-copy-process nil)
(defun wl-copy (text)
  (setq wl-copy-process (make-process :name "wl-copy"
                                      :buffer nil
                                      :command '("wl-copy" "-f" "-n")
                                      :connection-type 'pipe
                                      :noquery t))
  (process-send-string wl-copy-process text)
  (process-send-eof wl-copy-process))
(defun wl-paste ()
  (if (and wl-copy-process (process-live-p wl-copy-process))
      nil ; should return nil if we're the current paste owner
    (shell-command-to-string "wl-paste -n")))
(setq interprogram-cut-function 'wl-copy)
(setq interprogram-paste-function 'wl-paste)
#+end_src

***** add to list

#+NAME: emacs-add-to-list
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; add-to-list
;; ----------------------------------------------------------------------------------

;; mutt
(add-to-list 'auto-mode-alist '("/mutt" . mail-mode))

;; exec-path add local bin directory
(add-to-list 'exec-path "~/bin")
#+end_src

***** add hook

#+NAME: emacs-add-hook
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; add-hook
;; ----------------------------------------------------------------------------------

;; Make shebang (#!) file executable when saved
(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)

;; visual line mode
(add-hook 'text-mode-hook 'visual-line-mode)

;; h1 line mode
(add-hook 'prog-mode-hook #'hl-line-mode)
(add-hook 'text-mode-hook #'hl-line-mode)
#+end_src

***** keymap global set

#+NAME: emacs-keymap-global-set
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; keymap-global-set
;; ----------------------------------------------------------------------------------

;; org-capture
(keymap-global-set "C-c c" 'org-capture)

;; press M-/ and invoke hippie-expand
(keymap-global-set "M-/" 'hippie-expand)

;; window-toggle-side-windows
(keymap-global-set "C-x x w" 'window-toggle-side-windows)

;; open dired side window
(keymap-global-set "C-x x s" 'my/window-dired-vc-root-left)
#+end_src

***** keymap set

#+NAME: emacs-keymap-set
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; keymap-set
;; ----------------------------------------------------------------------------------

(keymap-set global-map "C-c h" 'iedit-mode)
(keymap-set global-map "C-c l" 'org-store-link)
(keymap-set global-map "C-c a" 'org-agenda)

;; mpv seek to position at point
(keymap-set global-map "C-x ," 'my/mpv-seek-to-position-at-point)

;; mpv dired embark
(with-eval-after-load 'embark
  (define-key embark-file-map "l" #'mpv-play-marked-files))
#+end_src

***** fonts

#+NAME: emacs-fonts
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; fonts
;; ----------------------------------------------------------------------------------

(defvar efs/default-font-size 180)
(defvar efs/default-variable-font-size 180)
#+end_src

***** set face attribute

#+NAME: emacs-set-face-attribute
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; set-face-attribute
;; ----------------------------------------------------------------------------------

;; Set the default pitch face
(set-face-attribute 'default nil :font "Fira Code" :height efs/default-font-size)

;; Set the fixed pitch face
(set-face-attribute 'fixed-pitch nil :font "Fira Code" :height efs/default-font-size)

;; Set the variable pitch face
(set-face-attribute 'variable-pitch nil :font "Iosevka" :height efs/default-variable-font-size :weight 'regular)

;; tab bar background
(set-face-attribute 'tab-bar nil
                    :foreground "#93a1a1")

;; active tab
(set-face-attribute 'tab-bar-tab nil
                    :foreground "#51AFEF")

;; inactive tab
(set-face-attribute 'tab-bar-tab-inactive nil
                    :foreground "grey50")
#+end_src

***** doom modeline

#+NAME: emacs-doom-modeline
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; doom-modeline
;; ----------------------------------------------------------------------------------

(use-package doom-modeline
  :init
  (setq doom-modeline-icon t
        doom-modeline-buffer-file-name-style 'truncate-except-project
        doom-modeline-time-icon nil
        doom-modeline-buffer-encoding nil
        doom-modeline-major-mode-icon t
        doom-modeline-battery t
        doom-modeline-vcs-icon t
        doom-modeline-vcs-bar-width 4
        doom-modeline-vcs-max-length 15)
  (display-battery-mode t)
  :config
  (doom-modeline-mode 1)
  (doom-modeline-def-modeline 'main
    '(bar matches buffer-info remote-host buffer-position selection-info)
    '(misc-info minor-modes input-method buffer-encoding major-mode process vcs check battery time)))
#+end_src

****** info

#+begin_quote
A fancy and fast mode-line inspired by minimalism design.
#+end_quote

[[https://github.com/seagle0128/doom-modeline]]

***** evil 

#+NAME: emacs-evil
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; evil
;; ----------------------------------------------------------------------------------

(use-package evil
  :init
  (setq evil-want-keybinding nil
        evil-want-C-i-jump nil)
  :config
  (evil-mode 1))


;; ----------------------------------------------------------------------------------
;; evil-collection
;; ----------------------------------------------------------------------------------

(use-package evil-collection
  :after evil
  :config
  (evil-collection-init)
  ;; dired use h and l
  (evil-collection-define-key 'normal 'dired-mode-map
    "e" 'dired-find-file
    "h" 'dired-up-directory
    "l" 'dired-find-file-mpv))
#+end_src

****** info

#+begin_quote
Evil is an extensible vi layer for Emacs. It emulates the main features of Vim
#+end_quote

[[https://github.com/emacs-evil/evil]]

***** general packages

#+NAME: emacs-general-packages
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; general packages : use-package
;; ----------------------------------------------------------------------------------

(use-package csv-mode)
(use-package evil-leader)
(use-package git-auto-commit-mode)
(use-package iedit)
(use-package nerd-icons)
(use-package nix-mode)
(use-package s)
(use-package shrink-path)
(use-package wgrep)
(use-package yaml-mode)
(use-package systemd)
#+end_src

****** info
******* csv-mode

#+begin_quote
Major mode for editing comma/char separated values
#+end_quote

[[https://elpa.gnu.org/packages/csv-mode.html]]

******* evil-leader

#+begin_quote
Evil Leader provides the <leader> feature from Vim that provides an easy way to bind keys under a variable prefix key. 
#+end_quote

[[https://github.com/cofi/evil-leader]]

******* git-auto-commit-mode

#+begin_quote
git-auto-commit-mode - Emacs minor mode to automatically commit (and push) a git repository.
#+end_quote

[[https://github.com/ryuslash/git-auto-commit-mode]]

******* iedit

#+begin_quote
Iedit - Edit multiple occurrences in the same way simultaneously
#+end_quote
  
[[https://github.com/victorhge/iedit]]

******* nerd-icons

#+begin_quote
Nerd-icons.el is a library for easily using Nerd Font icons inside Emacs
#+end_quote

[[https://github.com/rainstormstudio/nerd-icons.el]]

******* nix-mode

#+begin_quote
An Emacs major mode for editing Nix expressions.
#+end_quote

[[https://github.com/NixOS/nix-mode]]

******* s

#+begin_quote
The long lost Emacs string manipulation library.
#+end_quote

[[https://github.com/magnars/s.el/]]

******* shrink-path

#+begin_quote
Small utility functions that allow for fish-style trunctated directories in eshell and for example modeline.
#+end_quote

[[https://github.com/zbelial/shrink-path.el]]

******* wgrep

#+begin_quote
wgrep allows you to edit a grep buffer and apply those changes to the file buffer like sed interactively. 
#+end_quote

[[https://github.com/mhayashi1120/Emacs-wgrep]]

******* yaml-mode

#+begin_quote
yaml-mode - Simple major mode to edit YAML file for emacs
#+end_quote

[[https://github.com/yoshiki/yaml-mode]]

******* systemd

#+begin_quote
Major mode for editing systemd units in GNU Emacs. 
#+end_quote

[[https://github.com/holomorph/systemd-mode]]

***** ob sync

#+NAME: emacs-ob-sync
#+begin_src emacs-lisp
;;----------------------------------------------------------------------------------
;; ob-sync
;;----------------------------------------------------------------------------------

(use-package ob-async
  :config
  ;; ob-async sentinel fix
  (defun no-hide-overlays (orig-fun &rest args)
    (setq org-babel-hide-result-overlays nil))
  (advice-add 'ob-async-org-babel-execute-src-block :before #'no-hide-overlays))
#+end_src

***** which key

#+NAME: emacs-which-key
#+begin_src emacs-lisp
;;----------------------------------------------------------------------------------
;; which-key
;;----------------------------------------------------------------------------------

(use-package which-key
  :config
  (which-key-mode))
#+end_src

****** info

#+begin_quote
which-key is a minor mode for Emacs that displays the key bindings following your currently entered incomplete command (a prefix) in a popup.
#+end_quote

[[https://github.com/justbur/emacs-which-key]]

***** undo tree

#+NAME: emacs-undo-tree
#+begin_src emacs-lisp
;;----------------------------------------------------------------------------------
;; undo-tree
;;----------------------------------------------------------------------------------

(use-package undo-tree
  :config
  (global-undo-tree-mode 1)
  (setq undo-tree-visualizer-timestamps t
        undo-tree-visualizer-diff t))
#+end_src

****** info

#+begin_quote
The undo-tree-mode provided by this package replaces Emacs' undo system with a system that treats undo history as what it is: a branching tree of changes.
#+end_quote

[[https://www.dr-qubit.org/undo-tree.html]]

***** vertico

#+NAME: emacs-vertico
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Vertico
;; ----------------------------------------------------------------------------------

(use-package vertico
  :init
  (setq vertico-cycle t)
  :config
  (vertico-mode 1)
  ;; Add vertico keybindings here if they were from vertico-directory and are still desired.
  ;; C-j and C-k are usually default vertico navigation.
  ;; M-h for vertico-directory-up can be implemented as a custom function if needed.
  (with-eval-after-load 'evil
    (define-key vertico-map (kbd "C-j") 'vertico-next)
    (define-key vertico-map (kbd "C-k") 'vertico-previous)
    ;; Example for M-h if needed, requires defining a custom function or finding a vertico equivalent:
    ;; (define-key vertico-map (kbd "M-h") 'my-vertico-directory-up)
    ))
#+end_src

****** info

#+begin_quote
Vertico provides a performant and minimalistic vertical completion UI based on the default completion system.
#+end_quote

[[https://github.com/minad/vertico]]

***** marginalia

#+NAME: emacs-marginalia
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Marginalia
;; ----------------------------------------------------------------------------------

(use-package marginalia
  :init
  (setq marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
  :config
  (marginalia-mode 1))
#+end_src

****** info

#+begin_quote
This package provides marginalia-mode which adds marginalia to the minibuffer completions. Marginalia are marks or annotations placed at the margin of the page of a book or in this case helpful colorful annotations placed at the margin of the minibuffer for your completion candidates. 
#+end_quote

[[https://github.com/minad/marginalia]]

***** consult

#+NAME: emacs-consult
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Consult
;; ----------------------------------------------------------------------------------

(use-package consult
  :bind
  ("C-s" . consult-line)
  ("C-x b" . consult-buffer) ;; remap switch-to-buffer
  ("M-y" . consult-yank-pop) ;; Moved consult-yank-pop binding here
  :init
  (setq completion-in-region-function #'consult-completion-in-region
        enable-recursive-minibuffers t) ;; It lets you use a new minibuffer when you're in the minibuffer
  :config
  (define-key minibuffer-local-map (kbd "C-r") 'consult-history))
#+end_src

****** info

#+begin_quote
Consult provides search and navigation commands based on the Emacs completion function completing-read documented in the Elisp manual. Completion allows you to quickly select an item from a list of candidates. 
#+end_quote

[[https://github.com/minad/consult]]

***** orderless

#+NAME: emacs-orderless
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Orderless
;; ----------------------------------------------------------------------------------

(use-package orderless
  :init
  (setq completion-styles '(orderless basic)
        completion-category-overrides '((file (styles . (partial-completion))))))
#+end_src

****** info

#+begin_quote
This package provides an orderless completion style that divides the pattern into space-separated components, and matches candidates that match all of the components in any order. Each component can match in any one of several ways: literally, as a regexp, as an initialism, in the flex style, or as multiple word prefixes.
#+end_quote

[[https://github.com/oantolin/orderless]]

***** embark

#+NAME: emacs-embark
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Embark
;; ----------------------------------------------------------------------------------

(use-package embark
  :bind
  ([remap describe-bindings] . embark-bindings)
  ("C-," . embark-act)
  :init
  (setq prefix-help-command #'embark-prefix-help-command)
  :config
  (use-package embark-consult
    :after embark consult
    :hook (embark-collect-mode . consult-preview-at-point-mode))

  (defun embark-which-key-indicator ()
    "An embark indicator that displays keymaps using which-key.
  The which-key help message will show the type and value of the
  current target followed by an ellipsis if there are further
  targets."
    (lambda (&optional keymap targets prefix)
      (if (null keymap)
          (which-key--hide-popup-ignore-command)
        (which-key--show-keymap
         (if (eq (plist-get (car targets) :type) 'embark-become)
             "Become"
           (format "Act on %s '%s'%s"
                   (plist-get (car targets) :type)
                   (embark--truncate-target (plist-get (car targets) :target))
                   (if (cdr targets) "‚Ä¶" "")))
         (if prefix
             (pcase (lookup-key keymap prefix 'accept-default)
               ((and (pred keymapp) km) km)
               (_ (key-binding prefix 'accept-default)))
           keymap)
         nil nil t (lambda (binding)
                     (not (string-suffix-p "-argument" (cdr binding))))))))

  (setq embark-indicators
        '(embark-which-key-indicator
          embark-highlight-indicator
          embark-isearch-highlight-indicator))

  (defun embark-hide-which-key-indicator (fn &rest args)
    "Hide the which-key indicator immediately when using the completing-read prompter."
    (which-key--hide-popup-ignore-command)
    (let ((embark-indicators
           (remq #'embark-which-key-indicator embark-indicators)))
      (apply fn args)))

  (advice-add #'embark-completing-read-prompter
              :around #'embark-hide-which-key-indicator))
#+end_src

****** info

#+begin_quote
Embark makes it easy to choose a command to run based on what is near point, both during a minibuffer completion session (in a way familiar to Helm or Counsel users) and in normal buffers. Bind the command embark-act to a key and it acts like prefix-key for a keymap of actions (commands) relevant to the target around point.
#+end_quote

[[https://github.com/oantolin/embark]]

***** dired

#+NAME: emacs-dired
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; dired
;; ----------------------------------------------------------------------------------

;; dired hide long listing by default -- Define this function early and globally
(defun my-dired-mode-setup ()
  "Show less information in dired buffers."
  (dired-hide-details-mode 1))

;; Dired setq variables that are safe to set early
(setq dired-kill-when-opening-new-dired-buffer t
      dired-use-ls-dired t
      dired-listing-switches "-ahlv"
      dired-omit-mode t
      dired-recursive-copies 'always
      dired-recursive-deletes 'always
      dired-free-space nil
      dired-dwim-target t)

;; Configuration for built-in 'dired' and 'dired-x'
(with-eval-after-load 'dired
  (require 'dired-x) ;; Load dired-x functionalities

  ;; Set dired-omit-files after dired-x has loaded it
  (setq dired-omit-files (concat dired-omit-files "\\|^\\..+$"))
  (setq dired-guess-shell-alist-user '(("\\.pdf$" "zathura")))

  ;; dired hide async output buffer
  (add-to-list 'display-buffer-alist (cons "\\*Async Shell Command\\*.*" (cons #'display-buffer-no-window nil)))

  ;; Dired hooks (moved here to ensure my-dired-mode-setup is defined)
  (add-hook 'dired-mode-hook 'my-dired-mode-setup)
  (add-hook 'dired-mode-hook (lambda () (dired-omit-mode 1)))
  ;; media-thumbnail-dired-mode
  (define-key dired-mode-map (kbd "C-x m") 'media-thumbnail-dired-mode))


;; ------------------------------------------------------------------------------------------------
;; side-windows
;; ------------------------------------------------------------------------------------------------

;; dired-find-file-other-window 
;; bound to <S-return>, g O, <normal-state> <S-return>, <normal-state> g O

;; dired side window
(defun my/window-dired-vc-root-left ()
  (interactive)
  (let ((dir (if (eq (vc-root-dir) nil)
                 (dired-noselect default-directory)
               (dired-noselect (vc-root-dir)))))
    (display-buffer-in-side-window
     dir `((side . left)
           (slot . 0)
           (window-width . 0.20)
           (window-parameters . ((no-delete-other-windows . t)
                                 (mode-line-format . (""))))))))


;; ----------------------------------------------------------------------------------
;; media-thumbnail
;; ----------------------------------------------------------------------------------

;; use ffmpegthumbnailer to create thumbnails for videos

(use-package media-thumbnail
  :diminish media-thumbnail-dired-mode
  :commands (media-thumbnail-dired-mode)
  :config
  (setq media-thumbnail-image-width 480)
  (setq media-thumbnail-cache-dir 
        (file-name-concat temporary-file-directory "ffmpegthumbnailer/"))
  (setq media-thumbnail-dired-should-hide-details-fn #'ignore))


;; ----------------------------------------------------------------------------------
;; fd-dired
;; ----------------------------------------------------------------------------------

(use-package fd-dired
  :init
  (setq fd-dired-display-in-current-window nil))

;; switch to buffer results automatically
(defcustom fd-dired-display-in-current-window nil
  "Whether display result"
  :type 'boolean
  :safe #'booleanp
  :group 'fd-dired)


;; ----------------------------------------------------------------------------------
;; async and dired-async (dired-async is part of the async package)
;; ----------------------------------------------------------------------------------

(use-package async
  :config
  ;; Enable dired-async-mode after the async package is loaded
  (dired-async-mode 1))
#+end_src

****** info

#+begin_quote
Dired makes an Emacs buffer containing a listing of a directory, and optionally some of its subdirectories as well. You can use the normal Emacs commands to move around in this buffer, and special Dired commands to operate on the listed files. Dired works with both local and remote directories. 
#+end_quote

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html]]

***** ripgrep

#+NAME: emacs-ripgrep
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; rip-grep
;; ----------------------------------------------------------------------------------

(use-package rg
  :config
  ;; rip-grep automatically switch to results buffer
  ;; https://github.com/dajva/rg.el/issues/142
  (advice-add 'rg-run :after
              #'(lambda (_pattern _files _dir &optional _literal _confirm _flags) (pop-to-buffer (rg-buffer-name)))))
#+end_src

****** info

#+begin_quote
Ripgrep is a replacement for both grep like (search one file) and ag like (search many files) tools. It's fast and versatile and written in Rust.
#+end_quote

[[https://github.com/dajva/rg.el]]

***** tramp

#+NAME: emacs-tramp
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; tramp
;; ----------------------------------------------------------------------------------

(use-package tramp
  :init
  (setq tramp-default-method "ssh"
        tramp-allow-unsafe-temporary-files t)
  :config
  (tramp-set-completion-function "ssh"
                                 '((tramp-parse-sconfig "/etc/ssh_config")
                                   (tramp-parse-sconfig "~/.ssh/config")))
  ;; set tramp shell to bash to avoid zsh problems
  (setenv "SHELL" "/bin/sh")
  (add-to-list 'tramp-backup-directory-alist
               (cons tramp-file-name-regexp nil))
  (add-to-list 'backup-directory-alist (cons tramp-file-name-regexp nil)))
#+end_src

****** info

#+begin_quote
TRAMP stands for ‚ÄúTransparent Remote (file) Access, Multiple Protocol‚Äù. This package provides an easy, convenient, and consistent interface to editing remote files transparently, just as if they are local files. This extends to editing, version control, dired, and more. 
#+end_quote

[[https://www.gnu.org/software/tramp/]]

***** org mode

#+NAME: emacs-org-mode
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; org mode
;; ----------------------------------------------------------------------------------

(use-package org
  :defer t
  :init
  (setq org-agenda-files '("~/git/personal/org/")
        org-confirm-babel-evaluate nil
        org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-hide-emphasis-markers t
        org-tags-column 0
        org-src-preserve-indentation t
        org-src-window-setup 'current-window
        org-image-actual-width nil
        org-adapt-indentation nil
        org-export-async-debug t
        org-outline-path-complete-in-steps nil
        org-refile-use-outline-path t
        org-pandoc-options-for-latex-pdf '((latex-engine . "xelatex"))
        org-export-backends '(org md html latex icalendar odt ascii)
        org-todo-keywords
        '((sequence "TODO(t@/!)" "IN-PROGRESS(p/!)" "WAITING(w@/!)" "|" "DONE(d@)"))
        org-log-done t
        org-use-fast-todo-selection t
        org-log-into-drawer t
        org-file-apps
        (quote
         ((auto-mode . emacs)
          ("\\.mm\\'" . default)
          ("\\.x?html?\\'" . default)
          ("\\.mkv\\'" . "mpv %s")
          ("\\.mp4\\'" . "mpv %s")
          ("\\.mov\\'" . "mpv %s")
          ("\\.pdf\\'" . default)))
        browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "firefox")
  :config
  (require 'org-tempo)
  (require 'org-protocol)
  (require 'org-capture)
  (require 'org-faces)

  ;; org-timer covert seconds and milliseconds to hours, minutes, seconds, milliseconds
  (defun my/org-timer-secs-to-hms (s)
    "Convert integer S into hh:mm:ss.m
  If the integer is negative, the string will start with \"-\"."
    (let (sign m h)
      (setq x (number-to-string s)
            seconds (car (split-string x "[.]"))
            milliseconds (cadr (split-string x "[.]"))
            sec (string-to-number seconds)
            ms (string-to-number milliseconds))
      (setq sign (if (< sec 0) "-" "")
            sec (abs sec)
            m (/ sec 60) sec (- sec (* 60 m))
            h (/ m 60) m (- m (* 60 h)))
      (format "%s%02d:%02d:%02d.%02d" sign h m sec ms)))

  ;; org-timer covert hours, minutes, seconds, milliseconds to seconds, milliseconds
  (defun my/org-timer-hms-to-secs (hms)
    "Convert h:mm:ss string to an integer time.
  If the string starts with a minus sign, the integer will be negative."
    (if (not (string-match
              "\\([-+]?[0-9]+\\):\\([0-9]\\{2\\}\\):\\([0-9]\\{2\\}\\)\\([.]?[0-9]\\{0,3\\}\\)"
              hms))
        0
      (let* ((h (string-to-number (match-string 1 hms)))
             (m (string-to-number (match-string 2 hms)))
             (s (string-to-number (match-string 3 hms)))
             (ms (string-to-number (match-string 4 hms)))
             (sign (equal (substring (match-string 1 hms) 0 1) "-")))
        (setq h (abs h))
        (* (if sign -1 1) (+ s (+ ms (* 60 (+ m (* 60 h)))))))))

  ;; resize org headings
  (dolist (face '((org-level-1 . 1.2)
                  (org-level-2 . 1.1)
                  (org-level-3 . 1.05)
                  (org-level-4 . 1.0)
                  (org-level-5 . 1.1)
                  (org-level-6 . 1.1)
                  (org-level-7 . 1.1)
                  (org-level-8 . 1.1)))
    (set-face-attribute (car face) nil :font "Iosevka" :weight 'medium :height (cdr face)))

  (setq org-capture-templates
        '(("w" "web site" entry
           (file+olp "~/git/personal/bookmarks/bookmarks.org" "sites")
           "** [[%c][%^{link-description}]]"
           :empty-lines-after 1)
          ("v" "video url" entry
           (file+olp "~/git/personal/bookmarks/video.org" "links")
           "** [[video:%c][%^{link-description}]]"
           :empty-lines-after 1)))

  ;; refile
  (setq org-refile-targets '((nil :maxlevel . 2)
                             (org-agenda-files :maxlevel . 2)))

  (custom-set-faces
   '(org-link ((t (:inherit link :underline nil)))))

  (defadvice org-capture
      (after make-full-window-frame activate)
    "Advise capture to be the only window when used as a popup"
    (if (equal "emacs-capture" (frame-parameter nil 'name))
        (delete-other-windows)))

  (defadvice org-capture-finalize
      (after delete-capture-frame activate)
    "Advise capture-finalize to close the frame"
    (if (equal "emacs-capture" (frame-parameter nil 'name))
        (delete-frame)))

  ;; org-babel shell script
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)
     (emacs-lisp . t)
     (python . t)
     (dot . t)))

  ;; yank-media--registered-handlers org mode
  (setq yank-media--registered-handlers '(("image/.*" . #'org-mode--image-yank-handler)))

  ;; org mode image yank handler
  (yank-media-handler "image/.*" #'org-mode--image-yank-handler)

  ;; org-mode insert image as file link from the clipboard
  (defun org-mode--image-yank-handler (type image)
    (let ((file (read-file-name (format "Save %s image to: " type))))
      (when (file-directory-p file) (user-error "%s is a directory"))
      (when (and (file-exists-p file) (not (yes-or-no-p (format "%s exists; overwrite?" file)))) (user-error "%s exists"))
      (with-temp-buffer (set-buffer-multibyte nil) (insert image) (write-region (point-min) (point-max) file))
      (insert (format "[[file:%s]]\n" (file-relative-name file))))))
#+end_src

****** info

#+begin_quote
A GNU Emacs major mode for keeping notes, authoring documents, computational notebooks, literate programming, maintaining to-do lists, planning projects, and more ‚Äî in a fast and effective plain text system.
#+end_quote

[[https://orgmode.org/]]

***** org tree slide

#+NAME: emacs-org-tree-slide
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; org tree slide
;; ----------------------------------------------------------------------------------

(use-package org-tree-slide
  :init
  (setq org-tree-slide-header nil
        org-tree-slide-activate-message "Presentation started"
        org-tree-slide-deactivate-message "Presentation finished"
        org-tree-slide-slide-in-effect t
        org-tree-slide-breakcrumbs " // "
        org-tree-slide-heading-emphasis nil
        org-tree-slide-slide-in-blank-lines 2
        org-tree-slide-indicator nil)
  :hook (org-tree-slide-play . my/presentation-setup)
  (org-tree-slide-stop . my/presentation-end)
  :config
  ;; presentation start
  (defun my/presentation-setup ()
    (setq-local mode-line-format nil)
    (setq-local face-remapping-alist '((default (:height 1.5) variable-pitch)
                                       (header-line (:height 4.0) variable-pitch)
                                       (org-document-title (:height 1.75) org-document-title)
                                       (org-code (:height 1.55) org-code)
                                       (org-verbatim (:height 1.55) org-verbatim)
                                       (org-block (:height 1.25) org-block)
                                       (org-block-begin-line (:height 0.7) org-block))))

  ;; presentation end
  (defun my/presentation-end ()
    (doom-modeline-set-modeline 'main)
    (setq-local face-remapping-alist '((default fixed-pitch default)))
    (setq-local face-remapping-alist '((default variable-pitch default))))

  ;; Make sure certain org faces use the fixed-pitch face when variable-pitch-mode is on
  (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-table nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-formula nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-code nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)
  ;; make #+ lines invisible during presentation
  (defvar my-hide-org-meta-line-p nil)
  (defun my-hide-org-meta-line ()
    (interactive)
    (setq my-hide-org-meta-line-p t)
    (set-face-attribute 'org-meta-line nil :foreground (face-attribute 'default :background)))
  (defun my-show-org-meta-line ()
    (interactive)
    (setq my-hide-org-meta-line-p nil)
    (set-face-attribute 'org-meta-line nil :foreground nil))
  (defun my-toggle-org-meta-line ()
    (interactive)
    (if my-hide-org-meta-line-p (my-show-org-meta-line) (my-hide-org-meta-line))))
#+end_src

****** info

#+begin_quote
The main purpose of this elisp is to handle each tree in an org buffer as a slide by simple narrowing. 
#+end_quote

[[https://github.com/takaxp/org-tree-slide]]

***** mpv

#+NAME: emacs-mpv
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; mpv.el 
;; ----------------------------------------------------------------------------------

(use-package mpv
  :init
  ;; mpv-default-options play fullscreen on second display
  (setq mpv-default-options '("--fs" "--fs-screen-name=DP-3"))


  :config
  ;; create a video: link type that opens a url using mpv-play-remote-video
  (org-link-set-parameters "video"
                           :follow #'mpv-play-remote-video
                           :store #'org-video-store-link)
  
  
  ;; org video store link
  (defun org-video-store-link ()
    "Store a link to a video url."
    (org-link-store-props
     :type "video"
     :link link
     :description description))
  
  
  ;; mpv-play-remote-video
  (defun mpv-play-remote-video (url &rest args)
    "Start an mpv process playing the video stream at URL."
    (interactive)
    (unless (mpv--url-p url)
      (user-error "Invalid argument: `%s' (must be a valid URL)" url))
    (if (not mpv--process)
        ;; mpv isnt running play file
        (mpv-start url)
      ;; mpv running append file to playlist
      (mpv--playlist-append url)))
  
  
  ;; mpv-play-clipboard - play url from clipboard
  (defun mpv-play-clipboard ()
    "Start an mpv process playing the video stream at URL."
    (interactive)
    (let ((url (current-kill 0 t)))
      (unless (mpv--url-p url)
        (user-error "Invalid argument: `%s' (must be a valid URL)" url))
      (if (not mpv--process)
          ;; mpv isnt running play file
          (mpv-start url)
        ;; mpv running append file to playlist
        (mpv--playlist-append url))))
  
  
  ;; create a mpv: link type that opens a file using mpv-play
  (defun org-mpv-complete-link (&optional arg)
    (replace-regexp-in-string
     "file:" "mpv:"
     (org-link-complete-file arg)
     t t))
  (org-link-set-parameters "mpv"
                           :follow #'mpv-play :complete #'org-mpv-complete-link)
  
  ;; M-RET will insert a new item with the timestamp of the current playback position
  (defun my:mpv/org-metareturn-insert-playback-position ()
    (when-let ((item-beg (org-in-item-p)))
      (when (and (not org-timer-start-time)
                 (mpv-live-p)
                 (save-excursion
                   (goto-char item-beg)
                   (and (not (org-invisible-p)) (org-at-item-timer-p))))
        (my/mpv-insert-playback-position t))))
  (add-hook 'org-metareturn-hook #'my:mpv/org-metareturn-insert-playback-position)


  ;; video and audio mime types
  (defvar supported-mime-types
    '("video/quicktime"
      "video/x-matroska"
      "video/mp4"
      "video/webm"
      "video/x-m4v"
      "video/x-msvideo"
      "audio/x-wav"
      "audio/mpeg"
      "audio/x-hx-aac-adts"
      "audio/mp4"
      "audio/flac"
      "audio/ogg"))
  
  ;; subr-x
  (load "subr-x")
  
  ;; get files mime type
  (defun get-mimetype (filepath)
    (string-trim
     (shell-command-to-string (concat "file -b --mime-type "
                                      (shell-quote-argument filepath)))))
  
  ;; dired-find-file-mpv
  (defun dired-find-file-mpv ()
    "Start an mpv process playing the file at PATH append subsequent files to the playlist"
    (interactive)
    (let ((file (dired-get-file-for-visit)))
      (if (member (get-mimetype file) supported-mime-types)
          (mpv-play-dired file)
        (dired-find-file))))


  ;; mpv play dired marked files
  (defun mpv-play-marked-files ()
    "Play marked files with mpv"
    (interactive)
    (mapc 'mpv-play-dired (dired-get-marked-files nil nil nil t)))


  ;; frame step forward
  (defun mpv-frame-step ()
    "Step one frame forward."
    (interactive)
    (mpv--enqueue '("frame-step") #'ignore))
  
  
  ;; frame step backward
  (defun mpv-frame-back-step ()
    "Step one frame backward."
    (interactive)
    (mpv--enqueue '("frame-back-step") #'ignore))
  
  
  ;; mpv take a screenshot
  (defun mpv-screenshot ()
    "Take a screenshot"
    (interactive)
    (mpv--enqueue '("screenshot") #'ignore))
  
  
  ;; mpv show osd
  (defun mpv-osd ()
    "Show the osd"
    (interactive)
    (mpv--enqueue '("set_property" "osd-level" "3") #'ignore))
  
  
  ;; add a newline in the current document
  (defun end-of-line-and-indented-new-line ()
    (interactive)
    (end-of-line)
    (newline-and-indent))


  ;; mpv insert playback position
  (defun my/mpv-insert-playback-position (&optional arg)
    "Insert the current playback position at point.

  When called with a non-nil ARG, insert a timer list item like `org-timer-item'."
    (interactive "P")
    (let ((time (mpv-get-playback-position)))
      (funcall
       (if arg #'mpv--position-insert-as-org-item #'insert)
       (my/org-timer-secs-to-hms (float time)))))
  
  
  ;; seek to position
  (defun my/mpv-seek-to-position-at-point ()
    "Jump to playback position as inserted by `mpv-insert-playback-position'.

  This can be used with the `org-open-at-point-functions' hook."
    (interactive)
    (save-excursion
      (skip-chars-backward ":[:digit:]" (point-at-bol))
      (when (looking-at "[0-9]+:[0-9]\\{2\\}:[0-9]\\{2\\}\\([.]?[0-9]\\{0,3\\}\\)"))
      (let ((secs (my/org-timer-hms-to-secs (match-string 0))))
        (when (>= secs 0)
          (mpv-seek secs)))))

  
  ;; mpv-play-dired
  (defun mpv-play-dired (path)
    "Start an mpv process playing the file at PATH append subsequent files to the playlist"
    (if (not mpv--process)
        ;; mpv isnt running play file
        (mpv-start (expand-file-name path))
      ;; mpv running append file to playlist
      (mpv--playlist-append (expand-file-name path))))
  ) ;; This is the final closing parenthesis for the entire (use-package mpv ...) block
#+end_src

****** info

#+begin_quote
control mpv for easy note-taking

This package is a potpourri of helper functions to control a mpv process via its IPC interface.
#+end_quote

[[https://github.com/kljohann/mpv.el]]

***** emacs desktop notification center

#+NAME: emacs-ednc
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; emacs desktop notification center
;; ----------------------------------------------------------------------------------

;; start ednc-mode
(use-package ednc
  :init
  (ednc-mode 1)
  :config
  (defun show-notification-in-buffer (old new)
    (let ((name (format "Notification %d" (ednc-notification-id (or old new)))))
      (with-current-buffer (get-buffer-create name)
        (if new (let ((inhibit-read-only t))
                  (if old (erase-buffer) (ednc-view-mode))
                  (insert (ednc-format-notification new t))
                  (pop-to-buffer (current-buffer)))
          (kill-buffer)))))
  
  
  ;; notifications hook
  (add-hook 'ednc-notification-presentation-functions
            #'show-notification-in-buffer)
  
  ;; open notifications in side window
  (add-to-list 'display-buffer-alist
               '("^Notification *" display-buffer-in-side-window
                 (side . right)
                 (window-width . 0.50)))
  
  ;; ednc evil - normal mode
  (defun noevil ()
    (evil-define-key 'normal ednc-view-mode-map "d" 'ednc-dismiss-notification)
    (evil-define-key 'normal ednc-view-mode-map (kbd "RET") 'ednc-invoke-action)
    )
  (add-hook 'ednc-view-mode-hook 'noevil))
#+end_src

****** info

#+begin_quote
The Emacs Desktop Notification Center (EDNC) is an Emacs package written in pure Lisp that implements a Desktop Notifications service according to the freedesktop.org specification. EDNC aspires to be a small, but flexible drop-in replacement of standalone daemons like Dunst. 
#+end_quote

[[https://github.com/sinic/ednc]]

***** hydra

#+NAME: emacs-hydra
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; hydra
;; ----------------------------------------------------------------------------------

(use-package hydra
  :after mpv 
  :config
  ;; Define hydra-mpv
  (defhydra hydra-mpv (:hint nil)
    "
    ^Seek^                  ^Actions^               ^General^                       ^Playlists^
    ^^^^^^^^-----------------------------------------------------------------------------------------------------------
    _h_: seek back -5       _,_: back frame         _i_: insert playback position   _n_: next item in playlist
    _j_: seek back -60      _._: forward frame      _m_: insert a newline           _p_: previous item in playlist
    _k_: seek forward 60    _SPC_: pause            _s_: take a screenshot          _e_: jump to playlist entry
    _l_: seek forward 5     _q_: quit mpv           _o_: show the osd               _r_: remove playlist entry
    ^
    "
    ("h" mpv-seek-backward "-5")
    ("j" mpv-seek-backward "-60")
    ("k" mpv-seek-forward "60")
    ("l" mpv-seek-forward "5")
    ("," mpv-frame-back-step)
    ("." mpv-frame-step)
    ("SPC" mpv-pause)
    ("q" mpv-kill)
    ("i" my/mpv-insert-playback-position)
    ("m" end-of-line-and-indented-new-line)
    ("s" mpv-screenshot)
    ("o" mpv-osd)
    ("n" mpv-playlist-next)
    ("p" mpv-playlist-prev)
    ("e" mpv-jump-to-playlist-entry)
    ("r" mpv-remove-playlist-entry))

  ;; Define hydra-emacs
  (defhydra hydra-emacs (:hint nil :exit t)
    "
    ^Actions^
    ^^^^^^^^--------------
    _m_: mpv clipboard
    _p_: pinch url
    ^
    "
    ("m" mpv-play-clipboard)
    ("p" pinch-clipboard))

  ;; Define hydra-nested
  (defvar hydra-stack nil)

  (defhydra hydra-nested (:exit t)
    ("e" hydra-emacs/body "emacs" :column "hydra")
    ("m" hydra-mpv/body "mpv" :column "hydra")
    ("q" nil "quit"))

  ;; Set global keybinding
  (global-set-key (kbd "C-a") 'hydra-nested/body))
#+end_src

****** info

#+begin_quote
This is a package for GNU Emacs that can be used to tie related commands into a family of short bindings with a common prefix - a Hydra.
#+end_quote

[[https://github.com/abo-abo/hydra]]

***** google-translate

#+NAME: emacs-google-translate
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; google-translate
;; ----------------------------------------------------------------------------------

(use-package google-translate
  :config
  (setq google-translate-display-buffer-action
        '(pop-to-buffer-same-window)))
#+end_src

****** info

#+begin_quote
This package allows to translate the strings using Google Translate service directly from GNU Emacs.
#+end_quote

[[https://github.com/atykhonov/google-translate]]

***** magit

#+NAME: emacs-magit
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; magit
;; ----------------------------------------------------------------------------------

(use-package magit
  :init
  (setenv "SSH_AUTH_SOCK" "/run/user/1000/gcr/ssh"))
#+end_src

****** info

#+begin_quote
Magit is an interface to the version control system Git, implemented as an Emacs package. Magit aspires to be a complete Git porcelain. 
#+end_quote

[[https://github.com/magit/magit]]

***** markdown mode

#+NAME: emacs-markdown-mode
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; markdown mode
;; ----------------------------------------------------------------------------------

(use-package markdown-mode
  :commands (markdown-mode gfm-mode) ; Define mode functions to autoload the package
  :mode (("\\.md\\'" . markdown-mode) ; Use markdown-mode for *.md files
         ("\\.markdown\\'" . markdown-mode) ; Use markdown-mode for *.markdown files
         ("README\\.md\\'" . gfm-mode)) ; Use gfm-mode for README.md files
  :config
  (add-hook 'markdown-mode-hook 'visual-line-mode)
  (setq markdown-command "pandoc")
  )
#+end_src

****** info

#+begin_quote
markdown-mode is a major mode for editing Markdown-formatted text. 
#+end_quote

[[https://jblevins.org/projects/markdown-mode/]]

***** treesitter

#+NAME: emacs-treesitter
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; treesitter
;; ----------------------------------------------------------------------------------

(require 'treesit)

;; Use `major-mode-remap-alist` for languages that have a Treesitter major mode.
;; M-x treesit-install-language-grammar bash
(add-to-list
 'treesit-language-source-alist
 '(bash "https://github.com/tree-sitter/tree-sitter-bash.git" "v0.20.1"))

(setq major-mode-remap-alist
      '((sh-mode . bash-ts-mode)))

;; treesitter explore open in side window
(add-to-list 'display-buffer-alist
   '("^*tree-sitter explorer *" display-buffer-in-side-window
     (side . right)
     (window-width . 0.50)))
#+end_src

****** info

#+begin_quote
Emacs 29 introduces tree-sitter support, a powerful parsing library that enhances its understanding of source code. With this integration, Emacs gains features like precise syntax highlighting, accurate indentation and easier extensibility.
#+end_quote

[[https://www.masteringemacs.org/article/how-to-get-started-tree-sitter]]

***** yas snippet

#+NAME: emacs-yas-snippets
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Snippets (YASnippet)
;; ----------------------------------------------------------------------------------

(use-package yasnippet
  :init
  ;; Enable YASnippet globally for all modes.
  (yas-global-mode 1)
  :config
  ;; Load the built-in snippets after the package is ready.
  (yas-reload-all)

  ;; Optional: Set the key for manually expanding a snippet (if TAB is taken)
  ;; By default, TAB usually works unless another minor mode takes it.
  ;; If you need a separate key, uncomment the line below.
  ;; (define-key yas-minor-mode-map (kbd "C-c y") 'yas-expand)
  )

;; Install the massive collection of community snippets
(use-package yasnippet-snippets
  :after yasnippet)


;; ----------------------------------------------------------------------------------
;; YASnippet Completion-At-Point Function (CAPF)
;; ----------------------------------------------------------------------------------

(use-package yasnippet-capf
  ;; Ensure it loads after YASnippet and Cape (if Cape is being used to combine CAPFs)
  :after (yasnippet cape)
  :config
  ;; This function is the one that actually works!
  (add-to-list 'completion-at-point-functions #'yasnippet-capf))
#+end_src

****** info

#+begin_quote
YASnippet is a template system for Emacs. It allows you to type an abbreviation and automatically expand it into function templates. Bundled language templates include: C, C++, C#, Perl, Python, Ruby, SQL, LaTeX, HTML, CSS and more. The snippet syntax is inspired from TextMate's syntax, you can even import most TextMate templates to YASnippet. 
#+end_quote

[[https://github.com/joaotavora/yasnippet]]

***** corfu

#+NAME: emacs-corfu
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; corfu
;; ----------------------------------------------------------------------------------

(use-package corfu
  ;; Install the package if not found
  :init
  ;; Enable Corfu globally.
  (global-corfu-mode)

  :custom
  ;; Optional: Enable auto-completion after typing 0 characters (as-you-type)
  (corfu-auto t)
  ;; Optional: Set the delay before the popup appears to 0.1 seconds
  (corfu-auto-delay 0.1))

;; corfu complete
(with-eval-after-load 'evil
  ;; Bind C-. to the standard Emacs completion command, which Corfu is designed to use.
  (define-key evil-normal-state-map (kbd "C-.") 'completion-at-point)
  (define-key evil-insert-state-map (kbd "C-.") 'completion-at-point)
  (define-key evil-visual-state-map (kbd "C-.") 'completion-at-point)
  (define-key evil-motion-state-map (kbd "C-.") 'completion-at-point))

;; Set the global binding as well for non-Evil buffers
(keymap-global-set "C-." 'completion-at-point)
#+end_src

****** info

#+begin_quote
Corfu enhances in-buffer completion with a small completion popup. The current candidates are shown in a popup below or above the point, and can be selected by moving up and down. Corfu is the minimalistic in-buffer completion counterpart of the Vertico minibuffer UI.
#+end_quote

[[https://github.com/minad/corfu]]

***** cape

#+NAME: emacs-cape
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; cape
;; ----------------------------------------------------------------------------------

(use-package cape
  :config
  ;; Add a list of cape completion functions to the standard Emacs CAPF
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-keyword)
  )
#+end_src

****** info

#+begin_quote
Cape provides Completion At Point Extensions which can be used in combination with Corfu, Company or the default completion UI. The completion backends used by completion-at-point are so called completion-at-point-functions (Capfs).
#+end_quote

[[https://github.com/minad/cape]]

***** eglot

#+NAME: emacs-eglot
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; eglot
;; ----------------------------------------------------------------------------------

;; Configure Eglot to recognize and start the language servers.
(with-eval-after-load 'eglot
  ;; sh-mode (for shell scripts) uses 'bash-language-server' with a 'start' argument
  (add-to-list 'eglot-server-programs
               '(sh-mode "bash-language-server" "start"))

  ;; python-mode uses 'python-lsp-server', whose executable is typically 'pylsp'
  (add-to-list 'eglot-server-programs
               '(python-mode "pylsp")))

;; Automatically start Eglot when opening a relevant file
(add-hook 'sh-mode-hook 'eglot-ensure)
(add-hook 'python-mode-hook 'eglot-ensure)
#+end_src

****** info

#+begin_quote
Emacs Polyglot is the Emacs LSP client that stays out of your way:
#+end_quote

[[https://github.com/joaotavora/eglot]]

***** auth source

#+NAME: emacs-auth-source
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; auth-source
;; ----------------------------------------------------------------------------------

(require 'auth-source)
(add-to-list 'auth-sources (expand-file-name ".authinfo" user-emacs-directory))
#+end_src

****** info

#+begin_quote
It is a way for multiple applications to share a single configuration (in Emacs and in files) for user convenience. 
#+end_quote

[[https://www.gnu.org/software/emacs/manual/html_mono/auth.html]]

***** gptel

#+NAME: emacs-gptel
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; gptel
;; ----------------------------------------------------------------------------------

(use-package gptel
  :init
  ;; Enable tool use
  (setq gptel-use-tools t)
  (setq gptel-default-mode 'org-mode
        gptel-post-response-functions #'gptel-end-of-response
        gptel-expert-commands t)
  (require 'gptel-integrations) 
  :config
  (setq gptel-model 'gemini-2.5-flash
        gptel-backend (gptel-make-gemini "Gemini"
                        :key (gptel-api-key-from-auth-source "generativelanguage.googleapis.com")
                        :stream t))
  

;; ----------------------------------------------------------------------------------
;; display the Gemini buffer in same window
;; ----------------------------------------------------------------------------------

  (add-to-list 'display-buffer-alist
               '("^*Gemini*" display-buffer-same-window))


;; ----------------------------------------------------------------------------------
;; gptel set org source blocks to use sh and not bash
;; ----------------------------------------------------------------------------------

  (defun my/gptel-fix-src-header (beg end)
    (save-excursion
      (goto-char beg)
      (while (re-search-forward "^#\\+begin_src bash" end t)
        (replace-match "#+begin_src sh"))))

  (add-hook 'gptel-post-response-functions #'my/gptel-fix-src-header)


;; ----------------------------------------------------------------------------------
;; gptel-custom-tools.el loaded from ~/.config/emacs/lisp/gptel-custom-tools.el
;; ----------------------------------------------------------------------------------

  (load "gptel-custom-tools")) ;; gptel use-package config closing parentheses

#+end_src

****** info

#+begin_quote
gptel is a simple Large Language Model chat client for Emacs, with support for multiple models and backends. It works in the spirit of Emacs, available at any time and uniformly in any buffer.
#+end_quote

[[https://github.com/karthink/gptel]]

***** mcp server

#+NAME: emacs-mcp-server
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; mcp server
;; ----------------------------------------------------------------------------------

(use-package mcp
  :after gptel
  :custom
  (mcp-hub-servers `(("mcp-nixos" . (
                                     :command "podman" ; <-- Use your container runtime
                                     :args ("run" "--rm" "-i" "ghcr.io/utensils/mcp-nixos")))
                     ("searxng" . ( ; General web search tool
                                   :command "podman"
                                   :args ("run" "-i" "--rm"
                                          "--network=host"
                                          "-e" "SEARXNG_URL=http://localhost:8080"
                                          "mcp-searxng:local")
                                   ))
                     )) ;; closing parentheses

  :config
  (require 'mcp-hub))
#+end_src

****** info

#+begin_quote
This is an Emacs client for interfacing with MCP, supporting connections to MCP servers.
#+end_quote

[[https://github.com/lizqwerscott/mcp.el]]

***** docker

#+NAME: emacs-docker
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; docker
;; ----------------------------------------------------------------------------------

(use-package docker
  :bind ("C-c d" . docker)
  :custom
  (docker-command "podman"))
#+end_src

****** info

#+begin_quote
Emacs integration for Docker!

Supports docker containers, images, volumes, networks, contexts and docker-compose.
#+end_quote

[[https://github.com/Silex/docker.el]]

***** dockerfile mode

#+NAME: emacs-dockerfile-mode
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; dockerfile-mode
;; ----------------------------------------------------------------------------------

(use-package dockerfile-mode
  :custom
  (dockerfile-mode-command "podman"))
#+end_src

****** info

#+begin_quote
A Dockerfile mode for emacs

Adds syntax highlighting as well as the ability to build the image directly using C-c C-b from the buffer (C-c M-b to bypass docker build cache).
#+end_quote

[[https://github.com/spotify/dockerfile-mode]]

***** garbage collection

#+NAME: emacs-garbage-collection
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; garbage collection
;; ----------------------------------------------------------------------------------

;; Make gc pauses faster by decreasing the threshold.
(setq gc-cons-threshold (* 2 1000 1000))
(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(package-selected-packages nil))
#+end_src

**** early-init.el
:PROPERTIES:
:header-args: :noweb-ref early-init.el :noweb-sep "\n\n"
:END:

#+begin_example
~/.config/emacs/early-init.el
#+end_example

***** garbage collection

#+NAME: emacs-early-garbage
#+begin_src emacs-lisp
;;; early-init.el -*- lexical-binding: t; -*-

;; ----------------------------------------------------------------------------------
;; early-init.el
;; ----------------------------------------------------------------------------------

;; ----------------------------------------------------------------------------------
;;; Garbage collection
;; ----------------------------------------------------------------------------------

;; Increase the GC threshold for faster startup
;; The default is 800 kilobytes.  Measured in bytes.
(setq gc-cons-threshold (* 50 1000 1000))

;; Don‚Äôt compact font caches during GC.
(setq inhibit-compacting-font-caches t)
#+end_src

***** ui configuration

#+NAME: emacs-early-ui
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; ui configuration
;; ----------------------------------------------------------------------------------

;; Remove some unneeded UI elements (the user can turn back on anything they wish)
(setq inhibit-startup-message t)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(menu-bar-lines . 0) default-frame-alist)
(push '(vertical-scroll-bars) default-frame-alist)

;; start the initial frame maximized
(add-to-list 'initial-frame-alist '(fullscreen . maximized))

;; start every frame maximized
(add-to-list 'default-frame-alist '(fullscreen . maximized))

;; no title bar
(add-to-list 'default-frame-alist '(undecorated . t))
#+end_src

***** scratch buffer

#+NAME: emacs-early-scratch-buffer
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; scratch buffer
;; ----------------------------------------------------------------------------------

;; general settings
(setq initial-scratch-message nil)

;; Make the initial buffer load faster by setting its mode to fundamental-mode
(customize-set-variable 'initial-major-mode 'fundamental-mode)
#+end_src

***** lisp directory

#+NAME: emacs-early-lisp-dir
#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; personal elisp lib dir
;; ----------------------------------------------------------------------------------

;;Tell emacs where is your personal elisp lib dir
(add-to-list 'load-path "~/.config/emacs/lisp/")
#+end_src

**** lisp
***** gptel-custom-tools.el
:PROPERTIES:
:header-args: :noweb-ref gptel-custom-tools.el :noweb-sep "\n\n"
:END:
****** create_file

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; gptel-tools file tools
;; ----------------------------------------------------------------------------------

;; ----------------------------------------------------------------------------------
;; gptel-tools create file
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda (path filename content)
             (let ((full-path (expand-file-name filename path)))
               (with-temp-buffer
                 (insert content)
                 (write-file full-path))
               (format "Created file %s in %s" filename path)))
 :name "create_file"
 :description "Create a new file with the specified content"
 :args (list '(:name "path"
                     :type string
                     :description "The directory where to create the file")
             '(:name "filename"
                     :type string
                     :description "The name of the file to create")
             '(:name "content"
                     :type string
                     :description "The content to write to the file"))
 :category "filesystem")
#+end_src

****** read_file

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; gptel-tools read file
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda (filepath)
             (with-temp-buffer
               (insert-file-contents (expand-file-name filepath))
               (buffer-string)))
 :name "read_file"
 :description "Read and display the contents of a file"
 :args (list '(:name "filepath"
                     :type string
                     :description "Path to the file to read. Supports relative paths and ~."))
 :category "filesystem")
#+end_src

****** edit_file

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; gptel-tools edit file
;; ----------------------------------------------------------------------------------

(defun my-gptel--edit_file (file-path file-edits)
  "In FILE-PATH, apply FILE-EDITS with pattern matching and replacing."
  (if (and file-path (not (string= file-path "")) file-edits)
      (with-current-buffer (get-buffer-create "*edit-file*")
        (erase-buffer)
        (insert-file-contents (expand-file-name file-path))
        (let ((inhibit-read-only t)
              (case-fold-search nil)
              (file-name (expand-file-name file-path))
              (edit-success nil))
          ;; apply changes
          (dolist (file-edit (seq-into file-edits 'list))
            (when-let ((line-number (plist-get file-edit :line_number))
                       (old-string (plist-get file-edit :old_string))
                       (new-string (plist-get file-edit :new_string))
                       (is-valid-old-string (not (string= old-string ""))))
              (goto-char (point-min))
              (forward-line (1- line-number))
              (when (search-forward old-string nil t)
                (replace-match new-string t t)
                (setq edit-success t))))
          ;; return result to gptel
          (if edit-success
              (progn
                ;; show diffs
                (ediff-buffers (find-file-noselect file-name) (current-buffer))
                (format "Successfully edited %s" file-name))
            (format "Failed to edited %s" file-name))))
    (format "Failed to edited %s" file-path)))

(gptel-make-tool
 :function #'my-gptel--edit_file
 :name "edit_file"
 :description "Edit file with a list of edits, each edit contains a line-number,
a old-string and a new-string, new-string will replace the old-string at the specified line."
 :args (list '(:name "file-path"
                     :type string
                     :description "The full path of the file to edit")
             '(:name "file-edits"
                     :type array
                     :items (:type object
                                   :properties
                                   (:line_number
                                    (:type integer :description "The line number of the file where edit starts.")
                                    :old_string
                                    (:type string :description "The old-string to be replaced.")
                                    :new_string
                                    (:type string :description "The new-string to replace old-string.")))
                     :description "The list of edits to apply on the file"))
 :category "filesystem")
#+end_src

****** read_buffer

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; gptel-tools read buffer
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda (buffer)
             (unless (buffer-live-p (get-buffer buffer))
               (error "Error: buffer %s is not live." buffer))
             (with-current-buffer buffer
               (buffer-substring-no-properties (point-min) (point-max))))
 :name "read_buffer"
 :description "Return the contents of an Emacs buffer"
 :args (list '(:name "buffer"
                     :type string
                     :description "The name of the buffer whose contents are to be retrieved"))
 :category "emacs")
#+end_src

****** get_docstring

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; gptel-tools: Emacs Introspection (Derived from emacs-mcp.el source)
;; https://github.com/mpontus/emacs-mcp
;; ----------------------------------------------------------------------------------


;; ----------------------------------------------------------------------------------
;; Emacs: get_docstring
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda (function-name)
             (let* ((symbol (intern-soft function-name))
                    (docstring (and symbol (documentation symbol))))
               (or docstring
                   (error "No docstring found for function: %s" function-name))))
 :name "get_docstring"
 :description "Get the docstring for an Emacs Lisp function.
 Provides the raw documentation string for any Emacs Lisp function.
 FUNCTION-NAME should be the name of the function as a string.
 Returns the full docstring or an error if the function doesn't exist."
 :args (list '(:name "function-name" :type string :description "The name of the function as a string."))
 :category "emacs")
#+end_src

****** describe_elisp_variable

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: describe_elisp_variable
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda (variable-name)
             (save-window-excursion
               (describe-variable (intern variable-name))
               (with-current-buffer "*Help*"
                 (let ((docstring (buffer-string)))
                   (kill-buffer)
                   docstring))))
 :name "describe_elisp_variable"
 :description "Describe an Emacs Lisp variable in detail.
 Provides comprehensive information about a variable including:
 - Current value
 - Documentation string
 - Whether it is customizable
 - Where it was defined
 VARIABLE-NAME should be the name of the variable as a string."
 :args (list '(:name "variable-name" :type string :description "The name of the variable as a string."))
 :category "emacs")
#+end_src

****** describe_key_binding

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: describe_key_binding
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda (key-sequence)
             (save-window-excursion
               (let ((key (kbd key-sequence)))
                 (describe-key key)
                 (with-current-buffer "*Help*"
                   (let ((result (buffer-string)))
                     (kill-buffer)
                     result)))))
 :name "describe_key_binding"
 :description "Display documentation of the function invoked by KEY-SEQUENCE.
 Provides information about what command a key sequence runs and its documentation.
 KEY-SEQUENCE should be in Emacs key notation as a string (e.g. \"C-x C-f\").
 Returns details about the key binding and the function it calls."
 :args (list '(:name "key-sequence" :type string :description "Key sequence in Emacs notation (e.g. \"C-x C-f\")."))
 :category "emacs")
#+end_src

****** describe_current_mode

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: describe_current_mode
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda ()
             (save-window-excursion
               (describe-mode)
               (with-current-buffer "*Help*"
                 (let ((result (buffer-string)))
                   (kill-buffer)
                   result))))
 :name "describe_current_mode"
 :description "Display documentation of current major mode and minor modes.
 Provides comprehensive information about:
 - The current major mode and its purpose
 - All enabled minor modes
 - Key bindings specific to these modes
 This helps understand the current editing environment and available commands."
 :args nil
 :category "emacs")
#+end_src

****** describe_elisp_function

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: describe_elisp_function 
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda (function-name)
             (save-window-excursion
               (describe-function (intern function-name))
               (with-current-buffer "*Help*"
                 (let ((result (buffer-string)))
                   (kill-buffer)
                   result))))
 :name "describe_elisp_function"
 :description "Display the full documentation of FUNCTION.
 Provides detailed information about an Emacs Lisp function including:
 - Its argument list
 - Full documentation string
 - Where it was defined
 - Key bindings that call this function
 FUNCTION-NAME should be the name of the function as a string."
 :args (list '(:name "function-name" :type string :description "The name of the function as a string."))
 :category "emacs")
#+end_src

****** describe_display_face

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: describe_display_face
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda (face-name)
             (save-window-excursion
               (describe-face (intern face-name))
               (with-current-buffer "*Help*"
                 (let ((result (buffer-string)))
                   (kill-buffer)
                   result))))
 :name "describe_display_face"
 :description "Display the properties of face FACE.
 Provides detailed information about a display face including:
 - Its appearance attributes (color, weight, slant, etc.)
 - Where it was defined
 - How it's currently displayed
 FACE-NAME should be the name of the face as a string.
 This is useful for understanding text styling in Emacs."
 :args (list '(:name "face-name" :type string :description "The name of the face as a string (e.g., 'default')."))
 :category "emacs")
#+end_src

****** describe_installed_package

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: describe_installed_package
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda (package-name)
             (save-window-excursion
               (require 'package)
               (describe-package (intern package-name))
               (with-current-buffer "*Help*"
                 (let ((result (buffer-string)))
                   (kill-buffer)
                   result))))
 :name "describe_installed_package"
 :description "Display the full documentation of PACKAGE.
 Provides comprehensive information about an installed package including:
 - Version information
 - Summary and description
 - Dependencies
 - Features provided
 PACKAGE-NAME should be the name of the package as a string.
 This helps understand what functionality a package provides."
 :args (list '(:name "package-name" :type string :description "The name of the package as a string."))
 :category "emacs")
#+end_src

****** list_all_bindings

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: list_all_bindings
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda ()
             (save-window-excursion
               (describe-bindings)
               (with-current-buffer "*Help*"
                 (let ((result (buffer-string)))
                   (kill-buffer)
                   result))))
 :name "list_all_bindings"
 :description "Display a buffer showing a list of all defined keys, and their definitions.
 Provides a comprehensive list of all currently active key bindings organized by prefix.
 This gives a complete overview of available commands and their key shortcuts.
 Useful for understanding what commands are available in the current context."
 :args nil
 :category "emacs")
#+end_src

****** describe_custom_theme

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: describe_custom_theme
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda (theme-name)
             (save-window-excursion
               (require 'custom)
               (describe-theme (intern theme-name))
               (with-current-buffer "*Help*"
                 (let ((result (buffer-string)))
                   (kill-buffer)
                   result))))
 :name "describe_custom_theme"
 :description "Display a description of the Custom theme THEME.
 Provides information about a specific Emacs theme including:
 - Its settings and customizations
 - Faces it defines or modifies
 - Where it was defined
 THEME-NAME should be the name of the theme as a string.
 This helps understand how a theme affects Emacs appearance."
 :args (list '(:name "theme-name" :type string :description "The name of the theme as a string."))
 :category "emacs")
#+end_src

****** describe_current_syntax

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: describe_current_syntax
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda ()
             (save-window-excursion
               (describe-syntax)
               (with-current-buffer "*Help*"
                 (let ((result (buffer-string)))
                   (kill-buffer)
                   result))))
 :name "describe_current_syntax"
 :description "Describe the syntax specifications in the current syntax table.
 Provides detailed information about how Emacs interprets different characters
 in the current buffer's major mode. This includes:
 - Which characters are considered word constituents
 - Which characters are considered punctuation
 - How comment and string delimiters are defined
 This is useful for understanding how Emacs parses text in different modes."
 :args nil
 :category "emacs")
#+end_src

****** apropos_command

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: apropos_command
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda (pattern)
             (require 'apropos)
             (save-window-excursion
               (apropos-command pattern)
               (with-current-buffer "*Apropos*"
                 (let ((result (buffer-string)))
                   (kill-buffer)
                   result))))
 :name "apropos_command"
 :description "Search for commands matching PATTERN.
 Finds and returns information about all Emacs commands whose names match PATTERN.
 PATTERN can be a regular expression or a simple string.
 Results include command names, key bindings, and brief descriptions.
 This is useful for discovering commands related to a specific topic or feature."
 :args (list '(:name "pattern" :type string :description "A string or regular expression to match command names."))
 :category "emacs")
#+end_src

****** apropos_variable

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: apropos_variable
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda (pattern)
             (require 'apropos)
             (save-window-excursion
               (apropos-variable pattern)
               (with-current-buffer "*Apropos*"
                 (let ((result (buffer-string)))
                   (kill-buffer)
                   result))))
 :name "apropos_variable"
 :description "Search for variables matching PATTERN.
 Finds and returns information about all Emacs variables whose names match PATTERN.
 PATTERN can be a regular expression or a simple string.
 Results include variable names, current values, and brief descriptions.
 This is useful for discovering configuration options related to a specific feature."
 :args (list '(:name "pattern" :type string :description "A string or regular expression to match variable names."))
 :category "emacs")
#+end_src

****** apropos_value

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: apropos_value
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda (pattern)
             (require 'apropos)
             (save-window-excursion
               (apropos-value pattern)
               (with-current-buffer "*Apropos*"
                 (let ((result (buffer-string)))
                   (kill-buffer)
                   result))))
 :name "apropos_value"
 :description "Search for variables with values matching PATTERN.
 Finds and returns information about Emacs variables whose values match PATTERN.
 PATTERN can be a regular expression or a simple string.
 Results include variable names, matching values, and brief descriptions.
 This is useful for finding variables set to specific values or containing certain data."
 :args (list '(:name "pattern" :type string :description "A string or regular expression to match variable values."))
 :category "emacs")
#+end_src

****** apropos_documentation

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: apropos_documentation
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda (pattern)
             (require 'apropos)
             (save-window-excursion
               (apropos-documentation pattern)
               (with-current-buffer "*Apropos*"
                 (let ((result (buffer-string)))
                   (kill-buffer)
                   result))))
 :name "apropos_documentation"
 :description "Search for symbols with documentation matching PATTERN.
 Finds and returns information about Emacs symbols whose documentation contains PATTERN.
 PATTERN can be a regular expression or a simple string.
 Results include symbol names and the matching portions of their documentation.
 This is useful for finding features described with specific terms in their documentation."
 :args (list '(:name "pattern" :type string :description "A string or regular expression to search within documentation strings."))
 :category "emacs")
#+end_src

****** apropos_all_symbols

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: apropos_all_symbols
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda (pattern)
             (require 'apropos)
             (save-window-excursion
               (apropos pattern)
               (with-current-buffer "*Apropos*"
                 (let ((result (buffer-string)))
                   (kill-buffer)
                   result))))
 :name "apropos_all_symbols"
 :description "Search for symbols whose names match PATTERN.
 Finds and returns information about all Emacs symbols whose names match PATTERN.
 PATTERN can be a regular expression or a simple string.
 Results include functions, variables, faces, and other symbols.
 This is the most general search tool and useful for broad exploration of Emacs features."
 :args (list '(:name "pattern" :type string :description "A string or regular expression to match symbol names."))
 :category "emacs")
#+end_src

****** info_get_node

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: info_get_node
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda (node-name)
             (require 'info)
             (save-window-excursion
               (info node-name)
               (with-current-buffer "*info*"
                 (let ((result (buffer-string)))
                   (kill-buffer)
                   result))))
 :name "info_get_node"
 :description "Display the contents of an Info node.
 Provides the full text content of a specific Info documentation node.
 NODE-NAME should be the name of the node as a string (e.g. \"(emacs)Basic\").
 Returns the text content of the specified Info node."
 :args (list '(:name "node-name" :type string :description "The Info node name as a string."))
 :category "emacs")
#+end_src

****** info_documentation_search

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: info_documentation_search
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda (topic)
             (require 'info)
             (save-window-excursion
               (info)
               (Info-search topic)
               (let ((result (format "Search results for '%s':\n\n" topic))
                     (node-name (format "%s" Info-current-node))
                     (file-name (format "%s" Info-current-file)))
                 (setq result (concat result
                                      (format "Found in node: %s in file: %s\n\n"
                                              node-name file-name)))
                 ;; Get context around the match
                 (let ((start (max (point-min) (- (point) 200)))
                       (end (min (point-max) (+ (point) 500))))
                   (setq result (concat result
                                        (buffer-substring-no-properties start end))))
                 (kill-buffer)
                 result)))
 :name "info_documentation_search"
 :description "Search for TOPIC in the Info documentation.
 Performs a search across Info documentation for the specified topic.
 TOPIC should be a string to search for.
 Returns a list of matching nodes and context around the matches."
 :args (list '(:name "topic" :type string :description "The topic string to search for."))
 :category "emacs")
#+end_src

****** info_index_lookup

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: info_index_lookup
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda (index-item)
             (require 'info)
             (save-window-excursion
               (info)
               (Info-index index-item)
               (with-current-buffer "*info*"
                 (let ((result (format "Index results for '%s':\n\n" index-item))
                       (node-name (format "%s" Info-current-node))
                       (file-name (format "%s" Info-current-file)))
                   (setq result (concat result
                                        (format "Found in node: %s in file: %s\n\n"
                                                node-name file-name)))
                   ;; Get the content of the node
                   (setq result (concat result (buffer-substring-no-properties (point-min) (point-max))))
                   (kill-buffer)
                   result))))
 :name "info_index_lookup"
 :description "Look up INDEX-ITEM in the indices of the Info documentation.
 Finds entries in Info documentation indices that match the specified item.
 INDEX-ITEM should be a string to look up in the indices.
 Returns information about matching index entries and their locations."
 :args (list '(:name "index-item" :type string :description "The item string to look up in the indices."))
 :category "emacs")
#+end_src

****** info_get_toc

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: info_get_toc
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda (manual)
             (require 'info)
             (save-window-excursion
               (info (concat "(" manual ")"))
               (Info-directory)
               (with-current-buffer "*info*"
                 (let ((result (format "Table of Contents for '%s':\n\n" manual)))
                   (setq result (concat result (buffer-substring-no-properties (point-min) (point-max))))
                   (kill-buffer)
                   result))))
 :name "info_get_toc"
 :description "Display the table of contents for a specific Info MANUAL.
 Provides the structure and organization of an Info manual.
 MANUAL should be the name of the manual as a string (e.g. \"emacs\").
 Returns the table of contents of the specified manual."
 :args (list '(:name "manual" :type string :description "The name of the Info manual as a string."))
 :category "emacs")
#+end_src

****** info_list_manuals

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: info_list_manuals
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda ()
             (require 'info)
             (save-window-excursion
               (info)
               (Info-directory)
               (with-current-buffer "*info*"
                 (let ((result "Available Info Manuals:\n\n"))
                   (setq result (concat result (buffer-substring-no-properties (point-min) (point-max))))
                   (kill-buffer)
                   result))))
 :name "info_list_manuals"
 :description "List all available Info manuals.
 Provides a comprehensive list of all Info documentation manuals available in the system.
 This helps discover what documentation is available for reference."
 :args nil
 :category "emacs")
#+end_src

****** get_emacs_version

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: get_emacs_version
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda ()
             (concat "Emacs Version:\n\n" (emacs-version)))
 :name "get_emacs_version"
 :description "Get detailed information about the current Emacs version.
 Provides version number, build details, and system configuration information.
 This helps understand the capabilities and limitations of the current Emacs instance."
 :args nil
 :category "emacs")
#+end_src

****** list_loaded_features

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: list_loaded_features
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda ()
             (let ((result "Loaded Features:\n\n"))
               (dolist (feature features)
                 (setq result (concat result (format "- %s\n" feature))))
               result))
 :name "list_loaded_features"
 :description "List all features (libraries) that have been loaded in Emacs.
 Provides a comprehensive list of all Emacs Lisp libraries currently loaded.
 This helps understand what functionality is available in the current session."
 :args nil
 :category "emacs")
#+end_src

****** list_installed_packages

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: list_installed_packages
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda ()
             (require 'package)
             (package-initialize)
             (let ((result "Installed Packages:\n\n"))
               (dolist (pkg package-alist)
                 (let* ((name (car pkg))
                        (desc (cadr pkg))
                        (version (package-desc-version desc))
                        (status (if (package-installed-p name) "Installed" "Not Installed")))
                   (setq result (concat result (format "- %s (%s): %s\n"
                                                       name version status)))))
               result))
 :name "list_installed_packages"
 :description "List all installed packages with their status and version.
 Provides a comprehensive overview of the user's package ecosystem."
 :args nil
 :category "emacs")
#+end_src

****** list_available_modes

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: list_available_modes
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda ()
             (let ((result "Available Major Modes:\n\n")
                   (modes '()))
               (mapatoms (lambda (sym)
                           (when (and (functionp sym)
                                      (string-match "-mode$" (symbol-name sym))
                                      (not (string-match "-minor-mode$" (symbol-name sym))))
                             (push (symbol-name sym) modes))))
               (setq modes (sort modes 'string<))
               (dolist (mode modes)
                 (setq result (concat result (format "- %s\n" mode))))
               result))
 :name "list_available_modes"
 :description "List all available major modes in this Emacs instance.
 Provides a comprehensive list of all major modes that can be used.
 This helps understand what file types and editing modes are supported."
 :args nil
 :category "emacs")
#+end_src

****** list_custom_variables

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: list_custom_variables
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda ()
             (require 'cus-edit)
             (let ((result "Customized Variables:\n\n"))
               (dolist (theme custom-enabled-themes)
                 (setq result (concat result (format "Theme: %s\n" theme))))
               (setq result (concat result "\nVariables:\n"))
               (mapatoms
                (lambda (symbol)
                  (when (and (boundp symbol)
                             (get symbol 'saved-value))
                    (setq result (concat result (format "- %s: %S\n"
                                                        symbol (symbol-value symbol)))))))
               result))
 :name "list_custom_variables"
 :description "List all customized variables in the current Emacs session.
 Shows variables that have been customized away from their default values.
 This helps understand how the user has personalized their Emacs."
 :args nil
 :category "emacs")
#+end_src

****** describe_matching_hooks

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: describe_matching_hooks
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda (hook-pattern)
             (let ((result (format "Hooks matching \"%s\":\n\n" hook-pattern))
                   (hooks '()))
               (mapatoms
                (lambda (symbol)
                  (when (and (boundp symbol)
                             (string-match "-hook$" (symbol-name symbol))
                             (string-match hook-pattern (symbol-name symbol)))
                    (push symbol hooks))))
               (setq hooks (sort hooks (lambda (a b) (string< (symbol-name a) (symbol-name b)))))
               (dolist (hook hooks)
                 (setq result (concat result (format "- %s:\n" hook)))
                 (let ((value (symbol-value hook)))
                   (if (not value)
                       (setq result (concat result "  (empty)\n"))
                     (dolist (func value)
                       (setq result (concat result (format "  - %s\n" func)))))))
               result))
 :name "describe_matching_hooks"
 :description "List and show the functions attached to hooks matching HOOK-PATTERN."
 :args (list '(:name "hook-pattern" :type string :description "A string or regex to match hook names (e.g., 'prog-mode')."))
 :category "emacs")
#+end_src

****** list_available_fonts

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: list_available_fonts
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda ()
             (let ((result "Available Fonts:\n\n")
                   (fonts (font-family-list)))
               (setq fonts (sort fonts 'string<))
               (dolist (font fonts)
                 (setq result (concat result (format "- %s\n" font))))
               result))
 :name "list_available_fonts"
 :description "List all available fonts in the current Emacs session.
 Shows what fonts can be used for display customization.
 This helps understand display capabilities and options."
 :args nil
 :category "emacs")
#+end_src

****** find_key_conflicts

#+begin_src emacs-lisp
;; ----------------------------------------------------------------------------------
;; Emacs: find_key_conflicts
;; ----------------------------------------------------------------------------------

(gptel-make-tool
 :function (lambda (prefix)
             (require 'help-fns)
             (let ((result (format "Key bindings starting with %s:\n\n" prefix))
                   (key (kbd prefix))
                   (map (current-global-map))
                   bindings)
               ;; This code block has a minor issue in the original file,
               ;; as it attempts to call lookup-key on a keymap which is not a vector.
               ;; The intention is to list all keys *under* the prefix, but since 
               ;; the exact logic is hard to reproduce reliably outside the package,
               ;; we simplify it to list all bindings that START with the prefix.
               (map-keymap
                (lambda (k v)
                  (when (and v (string-prefix-p prefix (key-description (vector k))))
                    (let ((key-desc (key-description (vector k))))
                      (push (cons key-desc v) bindings))))
                map)
               (setq bindings (sort bindings (lambda (a b) (string< (car a) (car b)))))
               (dolist (binding bindings)
                 (setq result (concat result (format "- %s: %s\n"
                                                     (car binding)
                                                     (cdr binding)))))
               result))
 :name "find_key_conflicts"
 :description "Find conflicting key bindings starting with PREFIX.
 Identifies key sequences that might shadow or conflict with each other.
 PREFIX should be a key prefix in string form (e.g. \"C-c\").
 This helps diagnose keybinding issues and conflicts."
 :args (list '(:name "prefix" :type string :description "The key prefix string to check (e.g. \"C-c\")."))
 :category "emacs")
#+end_src

**** bookmarks config

#+NAME: emacs-bookmarks
#+BEGIN_SRC emacs-lisp
;;;; Emacs Bookmark Format Version 1;;;; -*- coding: utf-8-emacs; mode: lisp-data -*-
;;; This format is meant to be slightly human-readable;
;;; nevertheless, you probably don't want to edit it.
;;; -*- End Of Bookmark File Format Version Stamp -*-
(("dotfiles"
 (filename . "~/git/debian/debian-dotfiles/debian-dotfiles.org")
 (front-context-string . "#+TITLE: debian ")
 (rear-context-string)
 (position . 1)
 (last-modified 26894 460 323387 672000))
("Desktop"
 (filename . "~/Desktop/")
 (front-context-string)
 (rear-context-string . "wilcox/Desktop:\n")
 (position . 27)
 (last-modified 26467 1247 366394 327000))
("video"
 (filename . "~/git/personal/bookmarks/video.org")
 (front-context-string . "* links\n** [[vid")
 (rear-context-string . "ARTUP: overview\n")
 (position . 42)
 (last-modified 26024 3044 81012 2000))
("bookmarks"
 (filename . "~/git/personal/bookmarks/bookmarks.org")
 (front-context-string . "#+STARTUP: overv")
 (rear-context-string)
 (position . 1)
 (last-modified 25703 35089 410375 479000))
("feeds"
 (filename . "~/git/personal/feeds/feeds.org")
 (front-context-string . "* elfeed :elfeed")
 (rear-context-string . "TARTUP: content\n")
 (position . 20)
 (last-modified 25692 54791 894815 365000))
("org-refile-last-stored"
 (filename . "~/git/personal/org/web.org")
 (front-context-string . "** [[https://its")
 (rear-context-string . "lview\" program.\n")
 (position . 173198))
("root"
 (filename . "/")
 (front-context-string . "bin -> usr/bin\n ")
 (rear-context-string . " 7 Oct 30 23:23 ")
 (position . 197))
("home"
 (filename . "~/")
 (front-context-string . "..\n  drwxr-xr-x ")
 (rear-context-string . " 3 Oct 30 23:26 ")
 (position . 178))
("cerberus"
 (filename . "~/git/cerberus/")
 (front-context-string . "7zip\n  drwxr-xr-")
 (rear-context-string . "96 Jan  4  2016 ")
 (position . 249))
)
#+END_SRC

*** emacs tangle
**** init.el
***** home dir

#+NAME: emacs-init.el-home-dir
#+BEGIN_SRC emacs-lisp :tangle "~/.config/emacs/init.el"
<<init.el>>
#+END_SRC

***** current dir

#+NAME: emacs-init.el-current-dir
#+BEGIN_SRC emacs-lisp :tangle ".config/emacs/init.el"
<<init.el>>
#+END_SRC

**** early-init.el
***** home dir

#+NAME: emacs-early-init.el-home-dir
#+BEGIN_SRC emacs-lisp :tangle "~/.config/emacs/early-init.el"
<<early-init.el>>
#+END_SRC

***** current dir

#+NAME: emacs-early-init.el-current-dir
#+BEGIN_SRC emacs-lisp :tangle ".config/emacs/early-init.el"
<<early-init.el>>
#+END_SRC

**** lisp
***** gptel-custom-tools.el
****** home dir

#+NAME: gptel-custom-tools.el-home-dir
#+BEGIN_SRC emacs-lisp :tangle "~/.config/emacs/lisp/gptel-custom-tools.el"
<<gptel-custom-tools.el>>
#+END_SRC
****** current dir

#+NAME: gptel-custom-tools.el-current-dir
#+BEGIN_SRC emacs-lisp :tangle ".config/emacs/lisp/gptel-custom-tools.el"
<<gptel-custom-tools.el>>
#+END_SRC

**** bookmarks
***** home dir

#+NAME: emacs-bookmarks-home-dir
#+BEGIN_SRC emacs-lisp :tangle "~/.config/emacs/bookmarks"
<<emacs-bookmarks>>
#+END_SRC

***** current dir

#+NAME: emacs-bookmarks-current-dir
#+BEGIN_SRC emacs-lisp :tangle ".config/emacs/bookmarks"
<<emacs-bookmarks>>
#+END_SRC

** alacritty
*** alacritty config

#+NAME: alacritty
#+BEGIN_SRC toml
[colors.bright]
black = "#000000"
blue = "#79a8ff"
cyan = "#4ae2f0"
green = "#70b900"
magenta = "#f78fe7"
red = "#ff6b55"
white = "#ffffff"
yellow = "#fec43f"

[colors.normal]
black = "#000000"
blue = "#2fafff"
cyan = "#00d3d0"
green = "#44bc44"
magenta = "#feacd0"
red = "#ff5f59"
white = "#989898"
yellow = "#d0bc00"

[colors.primary]
background = "#0D0E1C"
foreground = "#989898"

[env]
TERM = "xterm-256color"

[font]
size = 16.0

[font.bold]
family = "Fira Code"
style = "Bold"

[font.bold_italic]
family = "Fira Code"
style = "Bold Italic"

[font.italic]
family = "Fira Code"
style = "Italic"

[font.normal]
family = "Fira Code"
style = "Regular"

[window]
decorations = "none"
decorations_theme_variant = "Dark"
startup_mode = "Maximized"

[window.class]
general = "Alacritty"
instance = "Alacritty"

[window.padding]
x = 4
y = 4
#+END_SRC

*** alacritty tangle

+ home dir

#+NAME: alacritty-home-dir
#+BEGIN_SRC toml :tangle "~/.config/alacritty/alacritty.toml"
<<alacritty>>
#+END_SRC

+ current dir

#+NAME: alacritty-current-dir
#+BEGIN_SRC toml :tangle ".config/alacritty/alacritty.toml"
<<alacritty>>
#+END_SRC

** zsh
*** zsh config
**** zshrc

#+NAME: zshrc
#+BEGIN_SRC conf
#===============================================================================
# ~/.zshrc
#===============================================================================

#===============================================================================
# ssh zsh fix
#===============================================================================

[[ $TERM == "dumb" ]] && unsetopt zle && PS1='$ ' && return


#===============================================================================
# Keep 1000 lines of history within the shell and save it to ~/.zsh_history:
#===============================================================================

HISTSIZE=1000


#===============================================================================
# variables for PS3 prompt
#===============================================================================

newline=$'\n'
yesmaster='Yes Master ? '


#===============================================================================
# Source the git-prompt.sh script on Debian
#===============================================================================

source /usr/lib/git-core/git-sh-prompt


#===============================================================================
# export git status options
#===============================================================================

export GIT_PS1_SHOWDIRTYSTATE=true
export GIT_PS1_SHOWSTASHSTATE=true
export GIT_PS1_SHOWUNTRACKEDFILES=true
export GIT_PS1_SHOWUPSTREAM="auto"
export GIT_PS1_SHOWCOLORHINTS=true


#===============================================================================
# PS3 prompt function
#===============================================================================

function zle-line-init zle-keymap-select {
    # 1. Determine the mode string based on Zsh's internal KEYMAP variable
    local MODE_INDICATOR
    case $KEYMAP in
        vicmd)
            MODE_INDICATOR="[n] " # Normal Mode Indicator + a space
            ;;
        viins|main)
            MODE_INDICATOR="[i] " # Insert Mode Indicator + a space
            ;;
        ,*)
            MODE_INDICATOR="" # Fallback
            ;;
    esac

    # 2. Rebuild the PS1, inserting the MODE_INDICATOR on the second line
    PS1="[%n@%M %~]$(__git_ps1 "(%s) ")${newline}${MODE_INDICATOR}${yesmaster}"

    zle reset-prompt
}


#===============================================================================
# run PS3 prompt function
#===============================================================================

zle -N zle-line-init
zle -N zle-keymap-select


#===============================================================================
# set terminal window title to program name
#===============================================================================

case $TERM in
  (*xterm* | rxvt | rxvt-unicode-256color)
    function precmd {
      print -Pn "\e]0;%(1j,%j job%(2j|s|); ,)%~\a"
    }
    function preexec {
      printf "\033]0;%s\a" "$1"
    }
  ;;
esac


#===============================================================================
# Fix bugs when switching modes
#===============================================================================

bindkey -v # vi mode
bindkey "^?" backward-delete-char
bindkey "^u" backward-kill-line
bindkey "^a" beginning-of-line
bindkey "^e" end-of-line
bindkey "^k" kill-line


#===============================================================================
# Use modern completion system
#===============================================================================

autoload -Uz compinit
compinit


#===============================================================================
# Set/unset  shell options
#===============================================================================

setopt notify globdots pushdtohome cdablevars autolist
setopt recexact longlistjobs
setopt autoresume histignoredups pushdsilent noclobber
setopt autopushd pushdminus extendedglob rcquotes mailwarning
setopt histignorealldups sharehistory
#setopt auto_cd
cdpath=($HOME)
unsetopt bgnice autoparamslash


#===============================================================================
# Completion Styles
#===============================================================================

# list of completers to use
zstyle ':completion:*::::' completer _expand _complete _ignored _approximate

# allow one error for every three characters typed in approximate completer
zstyle -e ':completion:*:approximate:*' max-errors \
    'reply=( $(( ($#PREFIX+$#SUFFIX)/3 )) numeric )'
    
# insert all expansions for expand completer
zstyle ':completion:*:expand:*' tag-order all-expansions

# formatting and messages
zstyle ':completion:*' verbose yes
zstyle ':completion:*:descriptions' format '%B%d%b'
zstyle ':completion:*:messages' format '%d'
zstyle ':completion:*:warnings' format 'No matches for: %d'
zstyle ':completion:*:corrections' format '%B%d (errors: %e)%b'
zstyle ':completion:*' group-name ''

#eval "$(dircolors -b)"
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}
zstyle ':completion:*' list-colors ''

# match uppercase from lowercase
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'

# offer indexes before parameters in subscripts
zstyle ':completion:*:*:-subscript-:*' tag-order indexes parameters

# Filename suffixes to ignore during completion (except after rm command)
zstyle ':completion:*:*:(^rm):*:*files' ignored-patterns '*?.o' '*?.c~' \
    '*?.old' '*?.pro' '.hidden'

# ignore completion functions (until the _ignored completer)
zstyle ':completion:*:functions' ignored-patterns '_*'

# kill - red, green, blue
zstyle ':completion:*:*:kill:*' list-colors '=(#b) #([0-9]#)*( *[a-z])*=22=31=34'

# list optiones colour, white + cyan
zstyle ':completion:*:options' list-colors '=(#b) #(-[a-zA-Z0-9,]#)*(-- *)=36=37'

# zsh autocompletion for sudo and doas
zstyle ":completion:*:(sudo|su|doas):*" command-path /usr/local/bin /home/djwilcox/bin

# rehash commands
zstyle ':completion:*' rehash true


#===============================================================================
# highlighting
#===============================================================================

source /usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
ZSH_HIGHLIGHT_STYLES[suffix-alias]=fg=cyan,underline
ZSH_HIGHLIGHT_STYLES[precommand]=fg=cyan,underline
ZSH_HIGHLIGHT_STYLES[arg0]=fg=cyan
ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets pattern)
ZSH_HIGHLIGHT_PATTERNS=('rm -rf *' 'fg=white,bold,bg=red')


#===============================================================================
# vpn-route
#===============================================================================

_vpn-route() {
  local curcontext="$curcontext" state line
  typeset -A opt_args

  _arguments -s \
    '-c[OpenVPN configuration file]:config file:_files -g "*.ovpn"' \
    '-a[Authentication file]:auth file:_files -g "*.txt"' \
    '-h[Show help]'
}

compdef _vpn-route vpn-route


#===============================================================================
# transmission autocomplete
#===============================================================================

compdef _gnu_generic transmission-daemon
compdef _gnu_generic transmission-remote
compdef _gnu_generic transmission-show
compdef _gnu_generic transmission-cli
compdef _gnu_generic transmission-create
compdef _gnu_generic transmission-edit
compdef _gnu_generic transmission-pwgen


#===============================================================================
# aliases
#===============================================================================

# mpc host and socket
alias mpc='mpc --host="${HOME}/.config/mpd/socket"'
#+END_SRC

**** zshenv

#+NAME: zshenv
#+begin_src conf
#===============================================================================
# ~/.zshenv
#===============================================================================

#===============================================================================
# Path
#===============================================================================

typeset -U PATH path
path=("$HOME/bin" "${HOME}/.deno/bin" "/usr/bin" "$path[@]")
export PATH


#===============================================================================
# xdg directories
#===============================================================================

export XDG_CONFIG_HOME="$HOME/.config"
export XDG_CACHE_HOME="$HOME/.cache"
export XDG_DATA_HOME="$HOME/.local/share"


#===============================================================================
# ssh-add
#===============================================================================

export SSH_AUTH_SOCK="$XDG_RUNTIME_DIR/ssh-agent.socket"


#===============================================================================
# less
#===============================================================================

export LESSHISTFILE="${XDG_CONFIG_HOME}/less/history"
export LESSKEY="${XDG_CONFIG_HOME}/less/keys"


#===============================================================================
# wget
#===============================================================================

export WGETRC="$XDG_CONFIG_HOME/wget/wgetrc"


#===============================================================================
# libdvdcss
#===============================================================================

export DVDCSS_CACHE="${XDG_DATA_HOME}/dvdcss"


#===============================================================================
# set emacsclient as editor
#===============================================================================

export ALTERNATE_EDITOR=""
export EDITOR="emacsclient -a emacs"
export VISUAL="emacsclient -a emacs"


#===============================================================================
# tell ls to be colourfull
#===============================================================================

export LSCOLORS=ExFxCxDxBxegedabagacad
export CLICOLOR=1


#===============================================================================
# qt5
#===============================================================================

export QT_QPA_PLATFORMTHEME=qt5ct


#===============================================================================
# vi mode
#===============================================================================

export KEYTIMEOUT=1


#===============================================================================
# mpd host variable for mpc
#===============================================================================

export MPD_HOST="/home/djwilcox/.config/mpd/socket"


#===============================================================================
# gnome keyring
#===============================================================================

eval $(/usr/bin/gnome-keyring-daemon --start --components=gpg,pkcs11,secrets,ssh)
#+end_src

*** zsh tangle
**** zshrc tangle
***** home dir

#+NAME: zshrc-home-dir
#+BEGIN_SRC conf :tangle "~/.zshrc"
<<zshrc>>
#+END_SRC

***** current dir

#+NAME: zshrc-current-dir
#+BEGIN_SRC conf :tangle ".zshrc"
<<zshrc>>
#+END_SRC

**** zshenv tangle
***** home dir

#+NAME: zshenv-home-dir
#+BEGIN_SRC conf :tangle "~/.zshenv"
<<zshenv>>
#+END_SRC

***** current dir

#+NAME: zshenv-current-dir
#+BEGIN_SRC conf :tangle ".zshenv"
<<zshenv>>
#+END_SRC

** tmux
*** tmux config

#+NAME: tmux
#+BEGIN_SRC conf
# .tmux.conf

# vi mode
set-window-option -g mode-keys vi

# Some tweaks to the status line
#set -g status-right "%H:%M" # date and time
set -g status-right "" # date and time
set -g status-right-style fg=color245

# If running inside tmux ($TMUX is set), then change the status line to red
%if #{TMUX}
set -g status-bg red
%endif

# Enable RGB colour if running in xterm(1)
set-option -sa terminal-overrides ",xterm*:Tc"

# Change the default $TERM to screen
set -g default-terminal "xterm-256color"

# No bells at all
set -g bell-action none

# close panes after command has finished
set -g remain-on-exit off

# Change the prefix key to C-a
set -g prefix C-a
unbind C-b
bind C-a send-prefix

# Turn the mouse on, but without copy mode dragging
set -g mouse on

# multiple places
bind F set -w window-size

# Keys to toggle monitoring activity in a window and the synchronize-panes option
bind m set monitor-activity
bind y set synchronize-panes\; display 'synchronize-panes #{?synchronize-panes,on,off}'

# Start windows and panes at 1, not 0
set -g base-index 1
setw -g pane-base-index 1

# reload ~/.tmux.conf using PREFIX r
bind r source-file ~/.config/tmux/tmux.conf \; display "Reloaded!"

# default statusbar colors
set -g status-style bg=default,fg=yellow #yellow

# default window title colors
set -g window-status-style fg=brightblue,bg=default

# active window title colors
set -g window-status-current-style fg=black,bg=blue

# pane border
set -g pane-border-style fg=black #base02
set -g pane-active-border-style fg=black #base01

# message text
set -g message-style bg=black,fg=brightred #orange

# pane number display
set-option -g display-panes-active-colour blue #blue
set-option -g display-panes-colour brightred #orange

# clock
set-window-option -g clock-mode-colour green #green

# vim key bindings
setw -g mode-keys vi
bind h select-pane -L
bind j select-pane -D
bind k select-pane -U
bind l select-pane -R
bind-key -r C-h select-window -t :-
bind-key -r C-l select-window -t :+

# resize panes using PREFIX H, J, K, L
bind H resize-pane -L 5
bind J resize-pane -D 5
bind K resize-pane -U 5
bind L resize-pane -R 5

# copy and paste
set-window-option -g automatic-rename on

# toggle statusbar
bind-key s set -g status

# copying selection vim style
# requires xsel and xclip
bind-key Escape copy-mode			# enter copy mode; default [
bind-key p paste-buffer				# paste; (default hotkey: ] )
bind-key P choose-buffer 			# tmux clipboard history
bind-key + delete-buffer \; display-message "Deleted current Tmux Clipboard History"

# Send To Tmux Clipboard or System Clipboard
bind-key < run-shell "tmux set-buffer -- \"$(xsel -o -b)\"" \; display-message "Copy To Tmux Clipboard"
bind-key > run-shell 'tmux show-buffer | xsel -i -b' \; display-message "Copy To System Clipboard"

# Note: rectangle-toggle (aka Visual Block Mode) > hit v then C-v to trigger it
bind-key -T copy-mode-vi v send-keys -X begin-selection
bind-key -T copy-mode-vi V send-keys -X select-line
bind-key -T copy-mode-vi C-v send-keys -X rectangle-toggle
bind-key -T choice-mode-vi h send-keys -X tree-collapse
bind-key -T choice-mode-vi l send-keys -X tree-expand
bind-key -T choice-mode-vi H send-keys -X tree-collapse-all
bind-key -T choice-mode-vi L send-keys -X tree-expand-all
bind-key -T copy-mode-vi MouseDragEnd1Pane send-keys -X copy-pipe "xclip -in -selection clipboard"
bind-key -T copy-mode-vi y send-keys -X copy-pipe "xclip -in -selection clipboard"

# urlscan as context and url view
bind-key u capture-pane \; save-buffer /tmp/tmux-buffer \; \
new-window -n "urlscan" '$SHELL -c "urlscan < /tmp/tmux-buffer"'

# copy mode - emulate right click "search google for {text}" like you do in GUI web browsers. 
bind-key -T copy-mode-vi 'o' send-keys -X copy-selection \; \
new-window -n google \; send-keys -t google 'sr -browser=w3m google "$(tmux show-buffer)" && tmux kill-window' 'Enter'

# tmux auto rename pane 
set-option -g status-interval 1
set-option -g automatic-rename on
set-option -g automatic-rename-format "#{?#{==:#{pane_current_command},zsh},#{b:pane_current_path},#{pane_current_command}}"
#+END_SRC

*** tmux tangle
**** home dir

#+NAME: tmux-home-dir
#+BEGIN_SRC conf :tangle "~/.config/tmux/tmux.conf"
<<tmux>>
#+END_SRC

**** current dir

#+NAME: tmux-current-dir
#+BEGIN_SRC conf :tangle ".config/tmux/tmux.conf"
<<tmux>>
#+END_SRC

** mpv
*** mpv config
**** input.conf

#+NAME: input.conf
#+BEGIN_SRC conf
# vim keybindings
l seek  5
h seek -5
k seek  60
j seek -60

# subtitles
J cycle sub 
K cycle sub down

# Audio filters:
F1 show-text "F2: loudnorm | F3: dynaudnorm | F4: low Bass | F5: low Treble" 2000

# loudnorm:
F2 af toggle lavfi=[loudnorm=I=-16:TP=-3:LRA=4]

# dynaudnorm:
F3 af toggle lavfi=[dynaudnorm=g=5:f=250:r=0.9:p=0.5]

# lowered bass:
F4  af toggle "superequalizer=6b=2:7b=2:8b=2:9b=2:10b=2:11b=2:12b=2:13b=2:14b=2:15b=2:16b=2:17b=2:18b=2"

# lowered treble:
F5  af toggle "superequalizer=1b=2:2b=2:3b=2:4b=2:5b=2:6b=2:7b=2:8b=2:9b=2:10b=2:11b=2:12b=2"
#+END_SRC

**** mpv.conf

#+NAME: mpv.conf
#+BEGIN_SRC conf
# mpv.conf

# list profiles with: mpv --profile=help

# load hwdec profile automatically
profile=hwdec 

# hardware acceleration profile
[hwdec]
profile-desc="hardware acceleration, no cache, yt-dlp 1080 or less"
vo=gpu
hwdec=vaapi

# hide: GNOME's wayland compositor lacks support for the idle inhibit protocol. 
#msg-level=ffmpeg=fatal,vo/gpu/wayland=no
msg-level=ffmpeg=fatal

# cache no for internet streams
cache=no

# yt-dlp best format 1080 or less
ytdl-format="bestvideo[height<=?1080]+bestaudio/best"

# show milliseconds in the on screen display
osd-fractions

# alsa pipewire audio device
audio-device=alsa/pipewire

# youtube subs - J to switch to subs
sub-auto=fuzzy
ytdl-raw-options=sub-lang="en",write-sub=,write-auto-sub=
sub-font='Noto Color Emoji'

# screenshot timecode
screenshot-template="%F-[%P]v%#01n"


# cache profile: mpv --profile=cache
[cache]
profile-desc="hardware acceleration, cache, yt-dlp 1080 or less"
# include hwdec profile 
profile=hwdec
# override hwdec profile cache setting
cache=auto


# youtube conditional auto profile match any youtube url
[youtube]
profile-desc="youtube hardware acceleration, cache"
profile-cond=path:find('youtu%.?be') ~= nil
# include hwdec profile 
profile=hwdec
# override hwdec profile cache setting
cache=yes
# fullscreen 2nd display
fs
fs-screen=1

# archive.org conditional auto profile match any archive.org url
[archive]
profile-desc="archive hardware acceleration, cache"
profile-cond=path:find('archive.org') ~= nil
# include hwdec profile 
profile=hwdec
# override hwdec profile cache setting
cache=auto
# fullscreen 2nd display
fs
fs-screen=1


# bbc iplayer conditional auto profile match any bbc iplayer url
[iplayer]
profile-desc="archive hardware acceleration, cache"
profile-cond=path:find('bbc.co.uk/iplayer') ~= nil
# include hwdec profile 
profile=hwdec
# override hwdec profile cache setting
cache=no
# fullscreen 2nd display
fs
fs-screen=1


# bbc iplayer conditional auto profile match any bbc iplayer url
[bbc]
profile-desc="bbc hardware acceleration, cache"
profile-cond=path:find('bbc:pips:service') ~= nil
# include hwdec profile 
profile=hwdec
# override hwdec profile cache setting
cache=no
# fullscreen 2nd display
fs
fs-screen=1
#+END_SRC

*** mpv tangle
**** input.conf tangle

+ home dir

#+NAME: input.conf-home-dir
#+BEGIN_SRC conf :tangle "~/.config/mpv/input.conf"
<<input.conf>>
#+END_SRC

+ current dir

#+NAME: input.conf-current-dir
#+BEGIN_SRC conf :tangle ".config/mpv/input.conf"
<<input.conf>>
#+END_SRC

**** mpv.conf tangle

+ home dir

#+NAME: mpv.conf-home-dir
#+BEGIN_SRC conf :tangle "~/.config/mpv/mpv.conf"
<<mpv.conf>>
#+END_SRC

+ current dir

#+NAME: mpv.conf-current-dir
#+BEGIN_SRC conf :tangle ".config/mpv/mpv.conf"
<<mpv.conf>>
#+END_SRC

** yt-dlp
*** yt-dlp config

#+NAME: yt-dlp
#+BEGIN_SRC conf
# download 1080p video in mp4 format
#-f 'bestvideo[height<=1080][vcodec!=?vp9]+bestaudio[acodec!=?opus]'

# external downloader aria2
#--downloader aria2c --downloader-args aria2c:'-c -j 3 -x 3 -s 3 -k 1M'

# native downloader for dash and m3u8
--downloader 'dash,m3u8:native'

# restrict filenames
--restrict-filenames

# merge output format mkv
--merge-output-format mkv

# ouput template
-o '%(title)s-[%(id)s]-%(upload_date>%Y-%m-%d)s.%(ext)s'
#+END_SRC

*** yt-dlp tangle

+ home dir

#+NAME: yt-dlp-home-dir
#+BEGIN_SRC conf :tangle "~/.config/yt-dlp/config"
<<yt-dlp>>
#+END_SRC

+ current dir

#+NAME: yt-dlp-current-dir
#+BEGIN_SRC conf :tangle ".config/yt-dlp/config"
<<yt-dlp>>
#+END_SRC

** kodi
*** kodi config
**** playercorefactory.xml

#+NAME: playercorefactory.xml
#+BEGIN_SRC xml
<playercorefactory>
 <players>
   <player name="save url" type="ExternalPlayer" audio="true" video="true">
	<filename>printf</filename>
     <args>"%s\n" "{0}" > "$HOME/desktop/url-$(date +"%Y-%m-%d-%H-%M-%S").txt"</args>
     <hidexbmc>false</hidexbmc>
   </player>
   <player name="play" type="ExternalPlayer" audio="false" video="true">
	<filename>"$HOME/.venv/pilfer/bin/pilferplay"</filename>
     <args>-i "{0}"</args>
     <hidexbmc>true</hidexbmc>
   </player>  
   <player name="mpv" type="ExternalPlayer" audio="false" video="true">
	<filename>mpv</filename>
     <args>"{0}"</args>
     <hidexbmc>true</hidexbmc>
   </player>  
   <player name="emacs" type="ExternalPlayer" audio="false" video="true">
	<filename>emacsclient</filename>
     <args>-u -e "(mpv-play-remote-video \"{0}\")"</args>
     <hidexbmc>true</hidexbmc>
   </player>  
   <player name="record video" type="ExternalPlayer" audio="false" video="true">
	<filename>"tsp $HOME/.venv/pilfer/bin/pilfer"</filename>
     <args>-i "{0}" &</args>
     <hidexbmc>false</hidexbmc>
   </player>  
   <player name="record video - 30 minutes" type="ExternalPlayer" audio="false" video="true">
	<filename>"tsp $HOME/.venv/pilfer/bin/pilfer"</filename>
     <args>-i "{0}" -t 00:30:00 &</args>
     <hidexbmc>false</hidexbmc>
   </player> 
   <player name="record video - 1 hour" type="ExternalPlayer" audio="false" video="true">
	<filename>"ts $HOME/.venv/pilfer/bin/pilfer"</filename>
     <args>-i "{0}" -t 01:00:00 &</args>
     <hidexbmc>false</hidexbmc>
   </player> 
   <player name="record video - 2 hours" type="ExternalPlayer" audio="false" video="true">
	<filename>"tsp $HOME/.venv/pilfer/bin/pilfer"</filename>
     <args>-i "{0}" -t 02:00:00 &</args>
     <hidexbmc>false</hidexbmc>
   </player> 
   <player name="record video - 3 hours" type="ExternalPlayer" audio="false" video="true">
	<filename>"tsp $HOME/.venv/pilfer/bin/pilfer"</filename>
     <args>-i "{0}" -t 03:00:00 &</args>
     <hidexbmc>false</hidexbmc>
   </player> 
   <player name="record audio" type="ExternalPlayer" audio="true" video="true">
	<filename>"tsp $HOME/.venv/pilfer/bin/pilfer"</filename>
     <args>-a "{0}" &</args>
     <hidexbmc>false</hidexbmc>
   </player>  
   <player name="record audio - 30 minutes" type="ExternalPlayer" audio="true" video="true">
	<filename>"tsp $HOME/.venv/pilfer/bin/pilfer"</filename>
     <args>-a "{0}" -t 00:30:00 &</args>
     <hidexbmc>false</hidexbmc>
   </player> 
   <player name="record audio - 1 hour" type="ExternalPlayer" audio="true" video="true">
	<filename>"tsp $HOME/.venv/pilfer/bin/pilfer"</filename>
     <args>-a "{0}" -t 01:00:00 &</args>
     <hidexbmc>false</hidexbmc>
   </player> 
   <player name="record audio - 2 hours" type="ExternalPlayer" audio="true" video="true">
	<filename>"tsp $HOME/.venv/pilfer/bin/pilfer"</filename>
     <args>-a "{0}" -t 02:00:00 &</args>
     <hidexbmc>false</hidexbmc>
   </player> 
   <player name="record audio - 3 hours" type="ExternalPlayer" audio="true" video="true">
	<filename>"tsp $HOME/.venv/pilfer/bin/pilfer"</filename>
     <args>-a "{0}" -t 03:00:00 &</args>
     <hidexbmc>false</hidexbmc>
   </player> 
 </players>
 <rules action="overwrite">
   <rule internetstream="true" player="mpv"></rule>
   <rule video="true" player="mpv"></rule>
   <!-- <rule internetstream="true" player="play"></rule> -->

   <!-- change the default player below -->

   <!-- <rule protocols="nfs|smb" player="dvdplayer"></rule> -->
   <!-- uncomment to make play the default player
    <rule video="true" player="play"></rule>
   -->
   
   <!-- uncomment to make record the default player
    <rule video="true" player="record"></rule>
   -->
   
 </rules>
</playercorefactory>
#+END_SRC

*** kodi tangle
**** playercorefactory.xml tangle

+ home dir

#+NAME: playercorefactory.xml-home-dir
#+BEGIN_SRC xml :tangle "~/.kodi/userdata/playercorefactory.xml"
<<playercorefactory.xml>>
#+END_SRC

+ current dir

#+NAME: playercorefactory.xml-current-dir
#+BEGIN_SRC xml :tangle ".kodi/userdata/playercorefactory.xml"
<<playercorefactory.xml>>
#+END_SRC

** aria2c
*** aria2c config

#+NAME: aria2c
#+begin_src conf
# aria2 config
 bt-max-peers=0
 bt-request-peer-speed-limit=0
 max-overall-upload-limit=128k
 bt-external-ip=127.0.0.1
 dht-listen-port=6882
 enable-dht=true
 enable-peer-exchange=true
 listen-port=6881
 bt-force-encryption=true
 bt-min-crypto-level=arc4
 bt-require-crypto=true
 follow-torrent=mem
 seed-ratio=100
 seed-time=0
 socket-recv-buffer-size=1M
 event-poll=epoll
 realtime-chunk-checksum=true
 allow-overwrite=true
 always-resume=true
 auto-file-renaming=false
 continue=true
 remote-time=true
 peer-id-prefix=""
 user-agent=""
 summary-interval=0
 ftp-pasv=true
 ftp-reuse-connection=true
 metalink-language=en-US
 metalink-location=us
 metalink-preferred-protocol=https
 lowest-speed-limit=50K
 max-concurrent-downloads=10
 max-connection-per-server=3
 min-split-size=5M
 split=10
 check-certificate=true
 conditional-get=true
 disable-ipv6=true
 http-accept-gzip=true
#+end_src

*** aria2c tangle

+ home dir
  
#+NAME: aria2c-home-dir
#+begin_src conf :tangle "~/.config/aria2/aria2.conf"
<<aria2c>>
#+end_src

+ current dir

#+NAME: aria2c-current-dir
#+begin_src conf :tangle ".config/aria2/aria2.conf"
<<aria2c>>
#+end_src

** mpd
*** mpd config
**** mpd.conf config

#+NAME: mpd
#+BEGIN_SRC conf
music_directory		"~/Music"
playlist_directory	"~/.config/mpd/playlists"
db_file			"~/.config/mpd/mpd.db"
log_file		"~/.config/mpd/mpd.log"
pid_file		"~/.config/mpd/mpd.pid"
state_file		"~/.config/mpd/mpdstate"
sticker_file		"~/.config/mpd/sticker.sql"
bind_to_address		"/home/djwilcox/.config/mpd/socket"
auto_update    "yes"
decoder {
        plugin                  "hybrid_dsd"
        enabled                 "no"
#       gapless                 "no"
}
#audio_output {
#	type		"alsa"
#	name		"My ALSA Device"
#}

#audio_output {
#        type            "pulse"
#        name            "pulse audio"
#}


audio_output {
        type            "pipewire"
        name            "pipewire"
}

filesystem_charset		"UTF-8"
#+END_SRC

*** mpd tangle
**** mpd.conf tangle

+ home dir

#+NAME: mpd-home-dir
#+BEGIN_SRC conf :tangle "~/.config/mpd/mpd.conf"
<<mpd>>
#+END_SRC

+ current dir

#+NAME: mpd-current-dir
#+BEGIN_SRC conf :tangle ".config/mpd/mpd.conf"
<<mpd>>
#+END_SRC

** ncmpc
*** ncmpc config

#+NAME: ncmpc
#+BEGIN_SRC conf
##
## Configuration file for ncmpc (~/.ncmpc/config)
##

############## Connection ###################
## Connect to mpd running on a specified host
#host = "localhost"
#host = "127.0.0.1"
host = "/home/djwilcox/.config/mpd/socket"

## Connect to mpd on the specified port.
#port = 6600

## Connect to mpd using the specified password.
#password = "mpd"

############## Interface ####################
## Enable mouse support (if enabled at compile time).
#enable-mouse = no

## A list of screens to cycle through when using
## the previous/next screen commands (tab and shift+tab).
## names: playlist browse help artist search song keydef lyrics outputs
screen-list = playlist browse

## Default search mode for the search screen. The mode is an
## integer index, with  0  for title, 1 for artist, 2 for album,
## 3 for filename, and 4 for artist+title.
#search-mode = 0

## Auto center (center the playing track in the playlist)
#auto-center = no

## Show the most recent query when using find.
#find-show-last = no

## Wrapped find mode.
#find-wrap = yes

## Wrapped cursor movement.
wrap-around = yes

## Ring bell when find wraps around.
#bell-on-wrap = yes

## Sound audible bell on alerts.
#audible-bell = yes

## Enable visible bell on alerts.
#visible-bell = no

## Default crossfade time in seconds.
#crossfade-time = 10

## Seek forward/backward by NUM seconds.
seek-time = 30

############## Display ######################
## Show a list of the screens in the top line on startup.
#welcome-screen-list = yes

## Make the cursor as wide as the screen.
#wide-cursor = yes

## Use the terminal's hardware cursor instead of inverse colors
#hardware-cursor = yes

## Hide playlist cursor after x seconds (0 disables this feature).
#hide-cursor = 5

## Scroll the title if it is too long for the screen.
#scroll = yes

## The separator to show at the end of the scrolling title.
#scroll-sep = " *** "

## list-format
## The format used to display songs in the main window.
list-format = "%name%|[%artist% - ]%title%|%file%"

## The format used to display songs on the status line.
status-format = "[%artist% - ]%title%|%shortfile%"

## The time, in seconds, for which status messages will be displayed.
#status-message-time = 3

## Display the time in the status bar when idle.
#display-time = yes

## Sets whether to display remaining or elapsed time in
## the status window. Default is elapsed.
#timedisplay-type = elapsed

## Show the bitrate in the status bar when playing a stream.
visible-bitrate = yes

## Change the XTerm title (ncmpc will not restore the title).
#set-xterm-title = no

## The format used to for the xterm title when ncmpc is playing.
#xterm-title-format = "ncmpc: [ %name%|[%artist% - ]%title%|%file%]"

## Automatically save the lyrics after receiving them.
#lyrics-autosave = no

## Display song length in second column
#second-column = yes

############## Colors #######################
## colors: none, black, red, green, yellow, blue, magenta, cyan, white
## attributes: standout, underline, reverse, blink, dim, bold
##
## Colors can also be given as an integer representing a terminal specific
## color code. The special color, none, represents the terminals default color.

## Enable/disable colors.
#enable-colors = yes
enable-colors = no

## Set the background color.
color background = none

## Set the text color for the title row.
color title = none,black

## Set the text color for the title row (the bold part).
color title-bold = blue,bold

## Set the color of the line on the second row.
color line = black

## Set the text color used to indicate mpd flags on the second row.
color line-flags = black,bold

## Set the text color in the main area of ncmpc.
color list = none

## Set the bold text color in the main area of ncmpc.
color list-bold = none,bold

## Sets the text color of directories in the browser
color browser-directory = none

## Sets the text color of playlists in the browser
color browser-playlist = none

## Set the color of the progress indicator.
color progressbar = black

## Set the text color used to display mpd status in the status window.
color status-state = black,bold

## Set the text color used to display song names in the status window.
color status-song  = black

## Set the text color used to display time the status window.
color status-time  = black

## Text color used to display alerts in the status window.
color alert = black,bold

## Redefine any of the base colors.
## The RGB values must be an integer value between 0 and 1000.
## Note: Only some terminals allow redefinitions of colors!
#colordef yellow = 255, 140, 0
#+END_SRC

*** ncmpc tangle

+ home dir

#+NAME: ncmpc-home-dir
#+BEGIN_SRC conf :tangle "~/.config/ncmpc/config"
<<ncmpc>>
#+END_SRC

+ current dir

#+NAME: ncmpc-current-dir
#+BEGIN_SRC conf :tangle ".config/ncmpc/config"
<<ncmpc>>
#+END_SRC

** systemd
*** systemd config
**** ssh-agent.service

#+NAME: ssh-agent.service
#+BEGIN_SRC conf
[Unit]
Description=SSH key agent

[Service]
Type=forking
Environment=SSH_AUTH_SOCK=%t/ssh-agent.socket
ExecStart=/usr/bin/ssh-agent -a $SSH_AUTH_SOCK

[Install]
WantedBy=default.target
#+END_SRC

**** emacs.service

#+NAME: emacs.service
#+BEGIN_SRC conf
[Unit]
Description=Emacs: the extensible, self-documenting text editor

[Service]
Type=forking
ExecStart=/usr/bin/emacs --daemon
ExecStop=/usr/bin/emacsclient --eval "(kill-emacs)"
Restart=always

[Install]
WantedBy=default.target
#+END_SRC

**** mpd.service

#+NAME: mpd.service
#+BEGIN_SRC conf
[Unit]
Description=Music Player Daemon
After=network.target sound.target

[Service]
ExecStart=/usr/bin/mpd --no-daemon /home/djwilcox/.config/mpd/mpd.conf

[Install]
WantedBy=default.target
#+END_SRC

*** systemd tangle
**** ssh-agent.service

+ home dir

#+NAME: ssh-agent.service-home-dir
#+BEGIN_SRC conf :tangle "~/.config/systemd/user/ssh-agent.service"
<<ssh-agent.service>>
#+END_SRC

+ current dir

#+NAME: ssh-agent.service-current-dir
#+BEGIN_SRC conf :tangle ".config/systemd/user/ssh-agent.service"
<<ssh-agent.service>>
#+END_SRC

**** emacs.service

+ home dir

#+NAME: emacs.service-home-dir
#+BEGIN_SRC conf :tangle "~/.config/systemd/user/emacs.service"
<<emacs.service>>
#+END_SRC

+ current dir

#+NAME: emacs.service-current-dir
#+BEGIN_SRC conf :tangle ".config/systemd/user/emacs.service"
<<emacs.service>>
#+END_SRC

**** mpd.service

+ home dir

#+NAME: mpd.service-home-dir
#+BEGIN_SRC conf :tangle "~/.config/systemd/user/mpd.service"
<<mpd.service>>
#+END_SRC

+ current dir

#+NAME: mpd.service-current-dir
#+BEGIN_SRC conf :tangle ".config/systemd/user/mpd.service"
<<mpd.service>>
#+END_SRC

** user-dirs.dirs
*** user-dirs.dirs config

#+NAME: user-dirs.dirs
#+BEGIN_SRC conf
XDG_DESKTOP_DIR="$HOME/Desktop"
XDG_DOCUMENTS_DIR="$HOME/Documents"
XDG_DOWNLOAD_DIR="$HOME/Downloads"
XDG_MUSIC_DIR="$HOME/Music"
XDG_PICTURES_DIR="$HOME/Pictures"
XDG_VIDEOS_DIR="$HOME/Video"
#+END_SRC

*** user-dirs.conf config

#+NAME: user-dirs.conf
#+BEGIN_SRC conf
enabled=False
#+END_SRC

*** user-dirs.dirs tangle

+ home dir
  
#+NAME: user-dirs.dirs-home-dir
#+BEGIN_SRC conf :tangle "~/.config/user-dirs.dirs"
<<user-dirs.dirs>>
#+END_SRC
  
+ current dir

#+NAME: user-dirs.dirs-current-dir
#+BEGIN_SRC conf :tangle ".config/user-dirs.dirs"
<<user-dirs.dirs>>
#+END_SRC

*** user-dirs.conf tangle

+ home dir
  
#+NAME: user-dirs.conf-home-dir
#+BEGIN_SRC conf :tangle "~/.config/user-dirs.conf"
<<user-dirs.conf>>
#+END_SRC
  
+ current dir

#+NAME: user-dirs.conf-current-dir
#+BEGIN_SRC conf :tangle ".config/user-dirs.conf"
<<user-dirs.conf>>
#+END_SRC

** autostart
*** autostart config
**** nognome_notications config

#+NAME: nognome_notications
#+BEGIN_SRC conf
[Desktop Entry]
Type=Application
Exec=/usr/local/bin/nognome_notifications
Hidden=True
NoDisplay=True
X-GNOME-Autostart-enabled=true
Name=nognome_notifications
Comment=nognome_notifications
#+END_SRC

*** autostart tangle
**** nognome_notications tangle

+ home dir

#+NAME: nognome_notications-autostart-home-dir
#+BEGIN_SRC conf :tangle "~/.config/autostart/nognome_notications.desktop"
<<nognome_notications>>
#+END_SRC

+ current dir

#+NAME: nognome_notications-autostart-current-dir
#+BEGIN_SRC conf :tangle ".config/autostart/nognome_notications.desktop"
<<nognome_notications>>
#+END_SRC

** gitconfig
*** gitconfig config

#+NAME: gitconfig
#+BEGIN_SRC conf
[user]
name = Daniel J Wilcox
email = danieljwilcox@gmail.com
[color]
ui = true
#+END_SRC

*** gitconfig tangle

+ home dir

#+NAME: gitconfig-home-dir
#+BEGIN_SRC conf :tangle "~/.config/git/config"
<<gitconfig>>
#+END_SRC

+ current dir

#+NAME: gitconfig-current-dir
#+BEGIN_SRC conf :tangle ".config/git/gitconfig"
<<gitconfig>>
#+END_SRC

** gtk
*** gtk.css config 

#+NAME: gtk.css
#+BEGIN_SRC conf
vte-terminal,
terminal-window {
    padding: 4px 4px 4px 4px;
    -vte-terminal-inner-border: 4px 4px 4px 4px;
}
#+END_SRC

*** gtk-3.0 config 

#+NAME: gtk-3
#+BEGIN_SRC conf
[Settings]
gtk-theme-name=Yaru-blue-dark
gtk-icon-theme-name=Yaru-blue-dark
gtk-application-prefer-dark-theme=true
#+END_SRC

*** gtk-4.0 config 

#+NAME: gtk-4
#+BEGIN_SRC conf
[Settings]
gtk-theme-name=Yaru-blue-dark
gtk-icon-theme-name=Yaru-blue-dark
gtk-application-prefer-dark-theme=true
#+END_SRC

*** gtk.css tangle

+ home dir

#+NAME: gtk.css-home-dir
#+BEGIN_SRC conf :tangle "~/.config/gtk-3.0/gtk.css"
<<gtk.css>>
#+END_SRC

+ current dir

#+NAME: gtk.css-current-dir
#+BEGIN_SRC conf :tangle ".config/gtk-3.0/gtk.css"
<<gtk.css>>
#+END_SRC

*** gtk-3.0 tangle

+ home dir

#+NAME: gtk-3-home-dir
#+BEGIN_SRC conf :tangle "~/.config/gtk-3.0/settings.ini"
<<gtk-3>>
#+END_SRC

+ current dir

#+NAME: gtk-3-current-dir
#+BEGIN_SRC conf :tangle ".config/gtk-3.0/settings.ini"
<<gtk-3>>
#+END_SRC

*** gtk-4.0 tangle

+ home dir

#+NAME: gtk-4-home-dir
#+BEGIN_SRC conf :tangle "~/.config/gtk-4.0/settings.ini"
<<gtk-4>>
#+END_SRC

+ current dir

#+NAME: gtk-4-current-dir
#+BEGIN_SRC conf :tangle ".config/gtk-4.0/settings.ini"
<<gtk-4>>
#+END_SRC

** wget
*** wget config

#+NAME: wget
#+BEGIN_SRC conf
hsts-file=/home/djwilcox/.cache/wget-hsts
#+END_SRC

*** wget tangle

+ home dir

#+NAME: wget-home-dir
#+BEGIN_SRC conf :tangle "~/.config/wget/wgetrc"
<<wget>>
#+END_SRC

+ current dir

#+NAME: wget-current-dir
#+BEGIN_SRC conf :tangle ".config/wget/wgetrc"
<<wget>>
#+END_SRC

** xkb
*** xkb config
**** rules
***** evdev

#+NAME: evdev
#+begin_src conf
! option = symbols
  custom:alt_win_ctrl = +custom(alt_win_ctrl)

! include %S/evdev
#+end_src

***** evdev.xml

#+NAME: evdev.xml
#+begin_src xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE xkbConfigRegistry SYSTEM "xkb.dtd">
<xkbConfigRegistry version="1.1">
  <layoutList>
    <layout>
      <configItem>
        <name>gb</name>
      </configItem>
      <variantList>
        <variant>
          <configItem>
            <name>alt_win_ctrl</name>
            <shortDescription>alt_win_ctrl</shortDescription>
            <description>GB(alt_win_ctrl)</description>
          </configItem>
        </variant>
      </variantList>
    </layout>
  </layoutList>
  <optionList>
    <group allowMultipleSelection="true">
      <configItem>
        <name>custom</name>
        <description>custom options</description>
      </configItem>
      <option>
        <configItem>
          <name>custom:alt_win_ctrl</name>
          <description>Ctrl is mapped to Alt, Alt to Win, and Win to the Ctrl key.</description>
        </configItem>
      </option>
    </group>
  </optionList>
</xkbConfigRegistry>
#+end_src

**** symbols
***** custom

#+NAME: xkb-custom
#+BEGIN_SRC conf
// Ctrl is mapped to Alt, Alt to Win, and Win to the Ctrl key.
partial modifier_keys
xkb_symbols "alt_win_ctrl" {
    key <LALT> { [ Super_L ] };
    key <LWIN> { [ Control_L, Control_L ] };
    key <LCTL> { [ Alt_L, Meta_L ] };
    key <AE03> { [ 3, numbersign, sterling ] };
};
#+END_SRC

***** gb

#+NAME: xkb-gb
#+BEGIN_SRC conf
default partial alphanumeric_keys 
xkb_symbols "alt_win_ctrl" {

    // mac swap alt_win_ctrl

    // include "macintosh_vndr/gb"

    name[Group1]= "alt_win_ctrl - Mac";

    key <LALT> { [ Super_L ] };
    key <LWIN> { [ Control_L, Control_L ] };
    key <LCTL> { [ Alt_L, Meta_L ] };
    key <AE03> { [ 3, numbersign, sterling ] };
};
#+END_SRC

*** xkb tangle
**** rules
***** evdev

+ home dir

#+NAME: evdev-home-dir
#+BEGIN_SRC conf :tangle "~/.config/xkb/rules/evdev"
<<evdev>>
#+END_SRC

+ current dir

#+NAME: evdev-current-dir
#+BEGIN_SRC conf :tangle ".config/xkb/rules/evdev"
<<evdev>>
#+END_SRC

***** evdev.xml

+ home dir

#+NAME: evdev-home-dir
#+BEGIN_SRC conf :tangle "~/.config/xkb/rules/evdev.xml"
<<evdev.xml>>
#+END_SRC

+ current dir

#+NAME: evdev-current-dir
#+BEGIN_SRC conf :tangle ".config/xkb/rules/evdev.xml"
<<evdev.xml>>
#+END_SRC

**** symbols
***** custom

+ home dir

#+NAME: xkb-custom-home-dir
#+BEGIN_SRC conf :tangle "~/.config/xkb/symbols/custom"
<<xkb-custom>>
#+END_SRC

+ current dir

#+NAME: xkb-custom-current-dir
#+BEGIN_SRC conf :tangle ".config/xkb/symbols/custom"
<<xkb-custom>>
#+END_SRC

***** gb

+ home dir

#+NAME: xkb-gb-home-dir
#+BEGIN_SRC conf :tangle "~/.config/xkb/symbols/gb"
<<xkb-gb>>
#+END_SRC

+ current dir

#+NAME: xkb-gb-current-dir
#+BEGIN_SRC conf :tangle ".config/xkb/symbols/gb"
<<xkb-gb>>
#+END_SRC

